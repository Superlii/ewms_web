import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  hyphenate,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isBuiltInDirective,
  isHTMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-ZVUIOKCX.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  init_define_process_env
} from "./chunk-M7N4COWV.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly)
        continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
}
function isText(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      first.properties.unshift(prop);
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    let alreadyExists = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
    }
    if (!alreadyExists) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (true)
        ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function getCompatValue(key, context) {
  const config = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
function baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(parseChildren(context, 0, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
            warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!context.inPre && node.type === 2) {
        if (!/[^\t\r\n\f ]/.test(node.content)) {
          const prev = nodes[i - 1];
          const next = nodes[i + 1];
          if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find((p) => p.type === 6 && p.name === "inline-template");
    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
    let hasIf = false;
    let hasFor = false;
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      if (p.type === 7) {
        if (p.name === "if") {
          hasIf = true;
        } else if (p.name === "for") {
          hasFor = true;
        }
      }
      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection(context, start));
        break;
      }
    }
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0
  };
}
function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
          return true;
        }
      }
    } else {
      if (p.name === "is") {
        return true;
      } else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = /* @__PURE__ */ new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(context, 17, m.index);
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
    let isPropShorthand = startsWith(name, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(match2[2]);
      const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
      if (modifiers.includes("prop")) {
        checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4);
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18, m.index);
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk(root, context, isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12 && getConstantType(child.content, context) >= 2) {
      child.codegenNode = context.hoist(child.codegenNode);
      hoistedCount++;
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(child.branches[i2], context, child.branches[i2].children.length === 1);
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (true)
        ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = [...context.helpers.keys()];
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        makeBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
  const hasHelpers = ast.helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${ast.helpers.map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
  const VueBinding = runtimeGlobalName;
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  if (ast.helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = ${``}`);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText$1(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText$1(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(node);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(true);
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(createCompilerError(44, node.loc, void 0, message));
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(createCompilerError(29, branch.userKey.loc));
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`)
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
      true ? '"v-if"' : '""',
      "true"
    ]));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      makeBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(dir.exp, context);
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0
  };
  if (true) {
    validateBrowserExpression(result.source, context);
  }
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      if (true) {
        validateBrowserExpression(result.key, context, true);
      }
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
        if (true) {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    if (true) {
      validateBrowserExpression(result.value, context, true);
    }
  }
  return result;
}
function createAliasExpression(range, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
          parseResult.source,
          createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
        ]));
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn) {
  return createObjectExpression([
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ]);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  const isComponent2 = node.tagType === 1;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const { name, arg, exp, loc } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }
          if (isVBind) {
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                }
              }
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            mergeArgs.push({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        properties.push(...props2);
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
          createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
            propsExpression
          ])
        ]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize2(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp)
          slotName = p.exp;
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize2(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(node, context, nonNameProps);
    slotProps = props;
    if (directives.length) {
      context.onError(createCompilerError(36, directives[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ")
            break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation("COMPILER_FILTER", context, node.loc);
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(46));
    } else if (isModuleMode) {
      onError(createCompilerError(47));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(48));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(49));
  }
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(ast, extend({}, options, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {})
  }));
  return generate(ast, extend({}, options, {
    prefixIdentifiers
  }));
}
var errorMessages, FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, locStub, isStaticExp, isBuiltInType, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, propsHelperSet, deprecationData, decodeRE, decodeMap, defaultParserOptions, isSpecialTemplateDirective, allowHoistedHelperSet, PURE_ANNOTATION, isFunctionType, isStaticProperty, isStaticPropertyKey, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, forAliasRE, forIteratorRE, stripParensRE, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, cacheStringFunction, camelizeRE, camelize2, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen$1, transformMemo, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_define_process_env();
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `Error parsing JavaScript expression: `,
      [45]: `<KeepAlive> expects exactly one child component.`,
      [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [47]: `ES module mode is not supported in this build of compiler.`,
      [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [49]: `"scopeId" option is only supported in module mode.`,
      [50]: ``
    };
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    RESOLVE_DYNAMIC_COMPONENT = Symbol(true ? `resolveDynamicComponent` : ``);
    RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
    nonIdentifierRE = /^\d|[^\$\w]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    decodeRE = /&(gt|lt|amp|apos|quot);/g;
    decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
    };
    isSpecialTemplateDirective = makeMap(`if,else,else-if,for,slot`);
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*#__PURE__*/`;
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(node.content, context);
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(exp, context, dir.name === "slot");
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
          }
        };
      });
    });
    transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
        return () => {
          let childBlock;
          const { children } = forNode;
          if (isTemplate) {
            node.children.some((c) => {
              if (c.type === 1) {
                const key = findProp(c, "key");
                if (key) {
                  context.onError(createCompilerError(33, key.loc));
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ]));
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
          } else {
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
          }
        };
      });
    });
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.parseResult = parseForExpression(vFor.exp, context);
        if (result) {
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
        if (props.length > 0) {
          const propsBuildResult = buildProps(node, context);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(createCompilerError(45, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
      };
    };
    true ? Object.freeze({}) : {};
    true ? Object.freeze([]) : [];
    cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    camelizeRE = /-(\w)/g;
    camelize2 = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
    };
    fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = {
                      type: 8,
                      loc: child.loc,
                      children: [child]
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``));
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
              };
            }
          }
        };
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen.has(node) || context.inVOnce) {
          return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(cur.codegenNode, true);
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(createCompilerError(41, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      context.bindingMetadata[rawExp];
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen$1.has(node)) {
          return;
        }
        seen$1.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              makeBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMNodeTransforms: () => DOMNodeTransforms,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getInnerRange: () => getInnerRange,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isBuiltInType: () => isBuiltInType,
  isCoreComponent: () => isCoreComponent,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  makeBlock: () => makeBlock,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(code, loc, true ? DOMErrorMessages : void 0);
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter((c) => c.type !== 3 && !(c.type === 2 && !c.content.trim()));
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function compile(template, options = {}) {
  return baseCompile(template, extend({}, parserOptions, options, {
    nodeTransforms: [
      ignoreSideEffectTags,
      ...DOMNodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, isRawTextContainer, parserOptions, transformStyle, parseInlineCSS, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, warnTransitionChildren, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_define_process_env();
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
    V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
    V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
    V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    isRawTextContainer = makeMap("style,iframe,script,noscript", true);
    parserOptions = {
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (isBuiltInType(tag, `Transition`)) {
          return TRANSITION;
        } else if (isBuiltInType(tag, `TransitionGroup`)) {
          return TRANSITION_GROUP;
        }
      },
      getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      },
      getTextMode({ tag, ns }) {
        if (ns === 0) {
          if (tag === "textarea" || tag === "title") {
            return 1;
          }
          if (isRawTextContainer(tag)) {
            return 2;
          }
        }
        return 0;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
    };
    DOMErrorMessages = {
      [50]: `v-html is missing expression.`,
      [51]: `v-html will override element children.`,
      [52]: `v-text is missing expression.`,
      [53]: `v-text will override element children.`,
      [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [55]: `v-model argument is not supported on plain elements.`,
      [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [58]: `v-show is missing expression.`,
      [59]: `<Transition> expects exactly one child element or component.`,
      [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(50, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(51, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(52, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(53, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(createSimpleExpression(`textContent`, true), exp ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(createDOMCompilerError(55, dir.arg.loc));
      }
      function checkDuplicatedValue() {
        const value = findProp(node, "value");
        if (value) {
          context.onError(createDOMCompilerError(57, value.loc));
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(createDOMCompilerError(56, dir.loc));
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(createDOMCompilerError(54, dir.loc));
      }
      baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`, true);
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && (!isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(58, loc));
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    warnTransitionChildren = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (node.children.length && hasMultipleChildren(node)) {
              context.onError(createDOMCompilerError(59, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(createDOMCompilerError(60, node.loc));
        context.removeNode();
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [warnTransitionChildren] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      on: transformOn2,
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          n[k] = e[k];
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespace(runtimeDom);
    var compileCache = /* @__PURE__ */ Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = template;
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const { code } = compilerDom.compile(template, shared.extend({
        hoistStatic: true,
        onError,
        onWarn: (e) => onError(e, true)
      }, options));
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return compileCache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default")
        exports[k] = runtimeDom[k];
    });
    exports.compile = compileToFunction;
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/vue3-treeselect/dist/vue3-treeselect.common.js
var require_vue3_treeselect_common = __commonJS({
  "node_modules/vue3-treeselect/dist/vue3-treeselect.common.js"(exports, module) {
    init_define_process_env();
    module.exports = function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      "00ee": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var test = {};
        test[TO_STRING_TAG] = "z";
        module2.exports = String(test) === "[object z]";
      },
      "00fd": function(module2, exports2, __webpack_require__) {
        var Symbol2 = __webpack_require__("9e69");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }
        module2.exports = getRawTag;
      },
      "0366": function(module2, exports2, __webpack_require__) {
        var aFunction = __webpack_require__("1c0b");
        module2.exports = function(fn, that, length) {
          aFunction(fn);
          if (that === void 0)
            return fn;
          switch (length) {
            case 0:
              return function() {
                return fn.call(that);
              };
            case 1:
              return function(a) {
                return fn.call(that, a);
              };
            case 2:
              return function(a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function(a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function() {
            return fn.apply(that, arguments);
          };
        };
      },
      "0481": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var flattenIntoArray = __webpack_require__("a2bf");
        var toObject = __webpack_require__("7b0b");
        var toLength = __webpack_require__("50c4");
        var toInteger = __webpack_require__("a691");
        var arraySpeciesCreate = __webpack_require__("65f0");
        $({ target: "Array", proto: true }, {
          flat: function flat() {
            var depthArg = arguments.length ? arguments[0] : void 0;
            var O = toObject(this);
            var sourceLen = toLength(O.length);
            var A = arraySpeciesCreate(O, 0);
            A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toInteger(depthArg));
            return A;
          }
        });
      },
      "06cf": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var propertyIsEnumerableModule = __webpack_require__("d1e7");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        var toIndexedObject = __webpack_require__("fc6a");
        var toPrimitive = __webpack_require__("c04e");
        var has = __webpack_require__("5135");
        var IE8_DOM_DEFINE = __webpack_require__("0cfb");
        var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
          O = toIndexedObject(O);
          P = toPrimitive(P, true);
          if (IE8_DOM_DEFINE)
            try {
              return nativeGetOwnPropertyDescriptor(O, P);
            } catch (error) {
            }
          if (has(O, P))
            return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
        };
      },
      "0cb2": function(module2, exports2, __webpack_require__) {
        var toObject = __webpack_require__("7b0b");
        var floor = Math.floor;
        var replace = "".replace;
        var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
        module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
          var tailPos = position + matched.length;
          var m = captures.length;
          var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
          if (namedCaptures !== void 0) {
            namedCaptures = toObject(namedCaptures);
            symbols = SUBSTITUTION_SYMBOLS;
          }
          return replace.call(replacement, symbols, function(match, ch) {
            var capture;
            switch (ch.charAt(0)) {
              case "$":
                return "$";
              case "&":
                return matched;
              case "`":
                return str.slice(0, position);
              case "'":
                return str.slice(tailPos);
              case "<":
                capture = namedCaptures[ch.slice(1, -1)];
                break;
              default:
                var n = +ch;
                if (n === 0)
                  return match;
                if (n > m) {
                  var f = floor(n / 10);
                  if (f === 0)
                    return match;
                  if (f <= m)
                    return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                  return match;
                }
                capture = captures[n - 1];
            }
            return capture === void 0 ? "" : capture;
          });
        };
      },
      "0cfb": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var fails = __webpack_require__("d039");
        var createElement = __webpack_require__("cc12");
        module2.exports = !DESCRIPTORS && !fails(function() {
          return Object.defineProperty(createElement("div"), "a", {
            get: function() {
              return 7;
            }
          }).a != 7;
        });
      },
      "1276": function(module2, exports2, __webpack_require__) {
        "use strict";
        var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
        var isRegExp = __webpack_require__("44e7");
        var anObject = __webpack_require__("825a");
        var requireObjectCoercible = __webpack_require__("1d80");
        var speciesConstructor = __webpack_require__("4840");
        var advanceStringIndex = __webpack_require__("8aa5");
        var toLength = __webpack_require__("50c4");
        var callRegExpExec = __webpack_require__("14c3");
        var regexpExec = __webpack_require__("9263");
        var fails = __webpack_require__("d039");
        var arrayPush = [].push;
        var min = Math.min;
        var MAX_UINT32 = 4294967295;
        var SUPPORTS_Y = !fails(function() {
          return !RegExp(MAX_UINT32, "y");
        });
        fixRegExpWellKnownSymbolLogic("split", 2, function(SPLIT, nativeSplit, maybeCallNative) {
          var internalSplit;
          if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
            internalSplit = function(separator, limit) {
              var string = String(requireObjectCoercible(this));
              var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
              if (lim === 0)
                return [];
              if (separator === void 0)
                return [string];
              if (!isRegExp(separator)) {
                return nativeSplit.call(string, separator, lim);
              }
              var output = [];
              var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
              var lastLastIndex = 0;
              var separatorCopy = new RegExp(separator.source, flags + "g");
              var match, lastIndex, lastLength;
              while (match = regexpExec.call(separatorCopy, string)) {
                lastIndex = separatorCopy.lastIndex;
                if (lastIndex > lastLastIndex) {
                  output.push(string.slice(lastLastIndex, match.index));
                  if (match.length > 1 && match.index < string.length)
                    arrayPush.apply(output, match.slice(1));
                  lastLength = match[0].length;
                  lastLastIndex = lastIndex;
                  if (output.length >= lim)
                    break;
                }
                if (separatorCopy.lastIndex === match.index)
                  separatorCopy.lastIndex++;
              }
              if (lastLastIndex === string.length) {
                if (lastLength || !separatorCopy.test(""))
                  output.push("");
              } else
                output.push(string.slice(lastLastIndex));
              return output.length > lim ? output.slice(0, lim) : output;
            };
          } else if ("0".split(void 0, 0).length) {
            internalSplit = function(separator, limit) {
              return separator === void 0 && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
            };
          } else
            internalSplit = nativeSplit;
          return [
            function split(separator, limit) {
              var O = requireObjectCoercible(this);
              var splitter = separator == void 0 ? void 0 : separator[SPLIT];
              return splitter !== void 0 ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
            },
            function(regexp, limit) {
              var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
              if (res.done)
                return res.value;
              var rx = anObject(regexp);
              var S = String(this);
              var C = speciesConstructor(rx, RegExp);
              var unicodeMatching = rx.unicode;
              var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (SUPPORTS_Y ? "y" : "g");
              var splitter = new C(SUPPORTS_Y ? rx : "^(?:" + rx.source + ")", flags);
              var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
              if (lim === 0)
                return [];
              if (S.length === 0)
                return callRegExpExec(splitter, S) === null ? [S] : [];
              var p = 0;
              var q = 0;
              var A = [];
              while (q < S.length) {
                splitter.lastIndex = SUPPORTS_Y ? q : 0;
                var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
                var e;
                if (z === null || (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
                  q = advanceStringIndex(S, q, unicodeMatching);
                } else {
                  A.push(S.slice(p, q));
                  if (A.length === lim)
                    return A;
                  for (var i = 1; i <= z.length - 1; i++) {
                    A.push(z[i]);
                    if (A.length === lim)
                      return A;
                  }
                  q = p = e;
                }
              }
              A.push(S.slice(p));
              return A;
            }
          ];
        }, !SUPPORTS_Y);
      },
      "1310": function(module2, exports2) {
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        module2.exports = isObjectLike;
      },
      "13d5": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $reduce = __webpack_require__("d58f").left;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var CHROME_VERSION = __webpack_require__("2d00");
        var IS_NODE = __webpack_require__("605d");
        var STRICT_METHOD = arrayMethodIsStrict("reduce");
        var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", { 1: 0 });
        var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
        $({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH || CHROME_BUG }, {
          reduce: function reduce(callbackfn) {
            return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "14c3": function(module2, exports2, __webpack_require__) {
        var classof = __webpack_require__("c6b6");
        var regexpExec = __webpack_require__("9263");
        module2.exports = function(R, S) {
          var exec = R.exec;
          if (typeof exec === "function") {
            var result = exec.call(R, S);
            if (typeof result !== "object") {
              throw TypeError("RegExp exec method returned something other than an Object or null");
            }
            return result;
          }
          if (classof(R) !== "RegExp") {
            throw TypeError("RegExp#exec called on incompatible receiver");
          }
          return regexpExec.call(R, S);
        };
      },
      "159b": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var DOMIterables = __webpack_require__("fdbc");
        var forEach = __webpack_require__("17c2");
        var createNonEnumerableProperty = __webpack_require__("9112");
        for (var COLLECTION_NAME in DOMIterables) {
          var Collection = global[COLLECTION_NAME];
          var CollectionPrototype = Collection && Collection.prototype;
          if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
            try {
              createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
            } catch (error) {
              CollectionPrototype.forEach = forEach;
            }
        }
      },
      "17c2": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $forEach = __webpack_require__("b727").forEach;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var STRICT_METHOD = arrayMethodIsStrict("forEach");
        var USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
        module2.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn) {
          return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } : [].forEach;
      },
      "1a8c": function(module2, exports2) {
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        module2.exports = isObject2;
      },
      "1be4": function(module2, exports2, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        module2.exports = getBuiltIn("document", "documentElement");
      },
      "1c0b": function(module2, exports2) {
        module2.exports = function(it) {
          if (typeof it != "function") {
            throw TypeError(String(it) + " is not a function");
          }
          return it;
        };
      },
      "1d80": function(module2, exports2) {
        module2.exports = function(it) {
          if (it == void 0)
            throw TypeError("Can't call method on " + it);
          return it;
        };
      },
      "1d92": function(module2, exports2, __webpack_require__) {
        var before = __webpack_require__("e0ef");
        function once(func) {
          return before(2, func);
        }
        module2.exports = once;
      },
      "1dde": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var wellKnownSymbol = __webpack_require__("b622");
        var V8_VERSION = __webpack_require__("2d00");
        var SPECIES = wellKnownSymbol("species");
        module2.exports = function(METHOD_NAME) {
          return V8_VERSION >= 51 || !fails(function() {
            var array = [];
            var constructor = array.constructor = {};
            constructor[SPECIES] = function() {
              return { foo: 1 };
            };
            return array[METHOD_NAME](Boolean).foo !== 1;
          });
        };
      },
      "23cb": function(module2, exports2, __webpack_require__) {
        var toInteger = __webpack_require__("a691");
        var max = Math.max;
        var min = Math.min;
        module2.exports = function(index, length) {
          var integer = toInteger(index);
          return integer < 0 ? max(integer + length, 0) : min(integer, length);
        };
      },
      "23e7": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var createNonEnumerableProperty = __webpack_require__("9112");
        var redefine = __webpack_require__("6eeb");
        var setGlobal = __webpack_require__("ce4e");
        var copyConstructorProperties = __webpack_require__("e893");
        var isForced = __webpack_require__("94ca");
        module2.exports = function(options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = global;
          } else if (STATIC) {
            target = global[TARGET] || setGlobal(TARGET, {});
          } else {
            target = (global[TARGET] || {}).prototype;
          }
          if (target)
            for (key in source) {
              sourceProperty = source[key];
              if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
              } else
                targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty === typeof targetProperty)
                  continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              redefine(target, key, sourceProperty, options);
            }
        };
      },
      "241c": function(module2, exports2, __webpack_require__) {
        var internalObjectKeys = __webpack_require__("ca84");
        var enumBugKeys = __webpack_require__("7839");
        var hiddenKeys = enumBugKeys.concat("length", "prototype");
        exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        };
      },
      "25f0": function(module2, exports2, __webpack_require__) {
        "use strict";
        var redefine = __webpack_require__("6eeb");
        var anObject = __webpack_require__("825a");
        var fails = __webpack_require__("d039");
        var flags = __webpack_require__("ad6d");
        var TO_STRING = "toString";
        var RegExpPrototype = RegExp.prototype;
        var nativeToString = RegExpPrototype[TO_STRING];
        var NOT_GENERIC = fails(function() {
          return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
        });
        var INCORRECT_NAME = nativeToString.name != TO_STRING;
        if (NOT_GENERIC || INCORRECT_NAME) {
          redefine(RegExp.prototype, TO_STRING, function toString() {
            var R = anObject(this);
            var p = String(R.source);
            var rf = R.flags;
            var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R) : rf);
            return "/" + p + "/" + f;
          }, { unsafe: true });
        }
      },
      "2655": function(module2, exports2) {
        module2.exports = isPromise;
        module2.exports.default = isPromise;
        function isPromise(obj) {
          return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
        }
      },
      "29f3": function(module2, exports2) {
        var objectProto = Object.prototype;
        var nativeObjectToString = objectProto.toString;
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        module2.exports = objectToString;
      },
      "2b3e": function(module2, exports2, __webpack_require__) {
        var freeGlobal = __webpack_require__("585a");
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        module2.exports = root;
      },
      "2d00": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var userAgent = __webpack_require__("342f");
        var process2 = global.process;
        var versions = process2 && process2.versions;
        var v8 = versions && versions.v8;
        var match, version;
        if (v8) {
          match = v8.split(".");
          version = match[0] + match[1];
        } else if (userAgent) {
          match = userAgent.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent.match(/Chrome\/(\d+)/);
            if (match)
              version = match[1];
          }
        }
        module2.exports = version && +version;
      },
      "2e39": function(module2, exports2, __webpack_require__) {
        "use strict";
        function fuzzysearch(needle, haystack) {
          var tlen = haystack.length;
          var qlen = needle.length;
          if (qlen > tlen) {
            return false;
          }
          if (qlen === tlen) {
            return needle === haystack;
          }
          outer:
            for (var i = 0, j = 0; i < qlen; i++) {
              var nch = needle.charCodeAt(i);
              while (j < tlen) {
                if (haystack.charCodeAt(j++) === nch) {
                  continue outer;
                }
              }
              return false;
            }
          return true;
        }
        module2.exports = fuzzysearch;
      },
      "3410": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var fails = __webpack_require__("d039");
        var toObject = __webpack_require__("7b0b");
        var nativeGetPrototypeOf = __webpack_require__("e163");
        var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeGetPrototypeOf(1);
        });
        $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
          getPrototypeOf: function getPrototypeOf(it) {
            return nativeGetPrototypeOf(toObject(it));
          }
        });
      },
      "342f": function(module2, exports2, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        module2.exports = getBuiltIn("navigator", "userAgent") || "";
      },
      "3729": function(module2, exports2, __webpack_require__) {
        var Symbol2 = __webpack_require__("9e69"), getRawTag = __webpack_require__("00fd"), objectToString = __webpack_require__("29f3");
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        module2.exports = baseGetTag;
      },
      "37e8": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var definePropertyModule = __webpack_require__("9bf2");
        var anObject = __webpack_require__("825a");
        var objectKeys = __webpack_require__("df75");
        module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys = objectKeys(Properties);
          var length = keys.length;
          var index = 0;
          var key;
          while (length > index)
            definePropertyModule.f(O, key = keys[index++], Properties[key]);
          return O;
        };
      },
      "3bbe": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        module2.exports = function(it) {
          if (!isObject2(it) && it !== null) {
            throw TypeError("Can't set " + String(it) + " as a prototype");
          }
          return it;
        };
      },
      "4069": function(module2, exports2, __webpack_require__) {
        var addToUnscopables = __webpack_require__("44d2");
        addToUnscopables("flat");
      },
      "408c": function(module2, exports2, __webpack_require__) {
        var root = __webpack_require__("2b3e");
        var now = function() {
          return root.Date.now();
        };
        module2.exports = now;
      },
      "4160": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var forEach = __webpack_require__("17c2");
        $({ target: "Array", proto: true, forced: [].forEach != forEach }, {
          forEach
        });
      },
      "428f": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        module2.exports = global;
      },
      "4416": function(module2, exports2) {
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : void 0;
        }
        module2.exports = last2;
      },
      "44ad": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var classof = __webpack_require__("c6b6");
        var split = "".split;
        module2.exports = fails(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(it) {
          return classof(it) == "String" ? split.call(it, "") : Object(it);
        } : Object;
      },
      "44d2": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var create = __webpack_require__("7c73");
        var definePropertyModule = __webpack_require__("9bf2");
        var UNSCOPABLES = wellKnownSymbol("unscopables");
        var ArrayPrototype = Array.prototype;
        if (ArrayPrototype[UNSCOPABLES] == void 0) {
          definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
            configurable: true,
            value: create(null)
          });
        }
        module2.exports = function(key) {
          ArrayPrototype[UNSCOPABLES][key] = true;
        };
      },
      "44e7": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        var classof = __webpack_require__("c6b6");
        var wellKnownSymbol = __webpack_require__("b622");
        var MATCH = wellKnownSymbol("match");
        module2.exports = function(it) {
          var isRegExp;
          return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
        };
      },
      "45fc": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $some = __webpack_require__("b727").some;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var STRICT_METHOD = arrayMethodIsStrict("some");
        var USES_TO_LENGTH = arrayMethodUsesToLength("some");
        $({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
          some: function some(callbackfn) {
            return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "4840": function(module2, exports2, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        var aFunction = __webpack_require__("1c0b");
        var wellKnownSymbol = __webpack_require__("b622");
        var SPECIES = wellKnownSymbol("species");
        module2.exports = function(O, defaultConstructor) {
          var C = anObject(O).constructor;
          var S;
          return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aFunction(S);
        };
      },
      "4930": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
          return !String(Symbol());
        });
      },
      "498a": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $trim = __webpack_require__("58a8").trim;
        var forcedStringTrimMethod = __webpack_require__("c8d2");
        $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
          trim: function trim() {
            return $trim(this);
          }
        });
      },
      "4b17": function(module2, exports2, __webpack_require__) {
        var toFinite = __webpack_require__("6428");
        function toInteger(value) {
          var result = toFinite(value), remainder = result % 1;
          return result === result ? remainder ? result - remainder : result : 0;
        }
        module2.exports = toInteger;
      },
      "4d64": function(module2, exports2, __webpack_require__) {
        var toIndexedObject = __webpack_require__("fc6a");
        var toLength = __webpack_require__("50c4");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var createMethod = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            if (IS_INCLUDES && el != el)
              while (length > index) {
                value = O[index++];
                if (value != value)
                  return true;
              }
            else
              for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el)
                  return IS_INCLUDES || index || 0;
              }
            return !IS_INCLUDES && -1;
          };
        };
        module2.exports = {
          includes: createMethod(true),
          indexOf: createMethod(false)
        };
      },
      "4de4": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $filter = __webpack_require__("b727").filter;
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
        var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          filter: function filter(callbackfn) {
            return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "4e82": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var aFunction = __webpack_require__("1c0b");
        var toObject = __webpack_require__("7b0b");
        var fails = __webpack_require__("d039");
        var arrayMethodIsStrict = __webpack_require__("a640");
        var test = [];
        var nativeSort = test.sort;
        var FAILS_ON_UNDEFINED = fails(function() {
          test.sort(void 0);
        });
        var FAILS_ON_NULL = fails(function() {
          test.sort(null);
        });
        var STRICT_METHOD = arrayMethodIsStrict("sort");
        var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD;
        $({ target: "Array", proto: true, forced: FORCED }, {
          sort: function sort(comparefn) {
            return comparefn === void 0 ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction(comparefn));
          }
        });
      },
      "50c4": function(module2, exports2, __webpack_require__) {
        var toInteger = __webpack_require__("a691");
        var min = Math.min;
        module2.exports = function(argument) {
          return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
        };
      },
      "5135": function(module2, exports2) {
        var hasOwnProperty = {}.hasOwnProperty;
        module2.exports = function(it, key) {
          return hasOwnProperty.call(it, key);
        };
      },
      "5319": function(module2, exports2, __webpack_require__) {
        "use strict";
        var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
        var anObject = __webpack_require__("825a");
        var toLength = __webpack_require__("50c4");
        var toInteger = __webpack_require__("a691");
        var requireObjectCoercible = __webpack_require__("1d80");
        var advanceStringIndex = __webpack_require__("8aa5");
        var getSubstitution = __webpack_require__("0cb2");
        var regExpExec = __webpack_require__("14c3");
        var max = Math.max;
        var min = Math.min;
        var maybeToString = function(it) {
          return it === void 0 ? it : String(it);
        };
        fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
          var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
          var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
          var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
          return [
            function replace(searchValue, replaceValue) {
              var O = requireObjectCoercible(this);
              var replacer = searchValue == void 0 ? void 0 : searchValue[REPLACE];
              return replacer !== void 0 ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
            },
            function(regexp, replaceValue) {
              if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                if (res.done)
                  return res.value;
              }
              var rx = anObject(regexp);
              var S = String(this);
              var functionalReplace = typeof replaceValue === "function";
              if (!functionalReplace)
                replaceValue = String(replaceValue);
              var global = rx.global;
              if (global) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
              }
              var results = [];
              while (true) {
                var result = regExpExec(rx, S);
                if (result === null)
                  break;
                results.push(result);
                if (!global)
                  break;
                var matchStr = String(result[0]);
                if (matchStr === "")
                  rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              }
              var accumulatedResult = "";
              var nextSourcePosition = 0;
              for (var i = 0; i < results.length; i++) {
                result = results[i];
                var matched = String(result[0]);
                var position = max(min(toInteger(result.index), S.length), 0);
                var captures = [];
                for (var j = 1; j < result.length; j++)
                  captures.push(maybeToString(result[j]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                  var replacerArgs = [matched].concat(captures, position, S);
                  if (namedCaptures !== void 0)
                    replacerArgs.push(namedCaptures);
                  var replacement = String(replaceValue.apply(void 0, replacerArgs));
                } else {
                  replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                }
                if (position >= nextSourcePosition) {
                  accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                  nextSourcePosition = position + matched.length;
                }
              }
              return accumulatedResult + S.slice(nextSourcePosition);
            }
          ];
        });
      },
      "5692": function(module2, exports2, __webpack_require__) {
        var IS_PURE = __webpack_require__("c430");
        var store = __webpack_require__("c6cd");
        (module2.exports = function(key, value) {
          return store[key] || (store[key] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: "3.8.2",
          mode: IS_PURE ? "pure" : "global",
          copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
        });
      },
      "56ef": function(module2, exports2, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        var getOwnPropertyNamesModule = __webpack_require__("241c");
        var getOwnPropertySymbolsModule = __webpack_require__("7418");
        var anObject = __webpack_require__("825a");
        module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
        };
      },
      "585a": function(module2, exports2, __webpack_require__) {
        (function(global) {
          var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
          module2.exports = freeGlobal;
        }).call(this, __webpack_require__("c8ba"));
      },
      "5899": function(module2, exports2) {
        module2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
      },
      "58a8": function(module2, exports2, __webpack_require__) {
        var requireObjectCoercible = __webpack_require__("1d80");
        var whitespaces = __webpack_require__("5899");
        var whitespace = "[" + whitespaces + "]";
        var ltrim = RegExp("^" + whitespace + whitespace + "*");
        var rtrim = RegExp(whitespace + whitespace + "*$");
        var createMethod = function(TYPE) {
          return function($this) {
            var string = String(requireObjectCoercible($this));
            if (TYPE & 1)
              string = string.replace(ltrim, "");
            if (TYPE & 2)
              string = string.replace(rtrim, "");
            return string;
          };
        };
        module2.exports = {
          start: createMethod(1),
          end: createMethod(2),
          trim: createMethod(3)
        };
      },
      "5c6c": function(module2, exports2) {
        module2.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        };
      },
      "605d": function(module2, exports2, __webpack_require__) {
        var classof = __webpack_require__("c6b6");
        var global = __webpack_require__("da84");
        module2.exports = classof(global.process) == "process";
      },
      "6428": function(module2, exports2, __webpack_require__) {
        var toNumber = __webpack_require__("b4b0");
        var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        module2.exports = toFinite;
      },
      "6547": function(module2, exports2, __webpack_require__) {
        var toInteger = __webpack_require__("a691");
        var requireObjectCoercible = __webpack_require__("1d80");
        var createMethod = function(CONVERT_TO_STRING) {
          return function($this, pos) {
            var S = String(requireObjectCoercible($this));
            var position = toInteger(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size)
              return CONVERT_TO_STRING ? "" : void 0;
            first = S.charCodeAt(position);
            return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
          };
        };
        module2.exports = {
          codeAt: createMethod(false),
          charAt: createMethod(true)
        };
      },
      "65f0": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        var isArray2 = __webpack_require__("e8b5");
        var wellKnownSymbol = __webpack_require__("b622");
        var SPECIES = wellKnownSymbol("species");
        module2.exports = function(originalArray, length) {
          var C;
          if (isArray2(originalArray)) {
            C = originalArray.constructor;
            if (typeof C == "function" && (C === Array || isArray2(C.prototype)))
              C = void 0;
            else if (isObject2(C)) {
              C = C[SPECIES];
              if (C === null)
                C = void 0;
            }
          }
          return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
        };
      },
      "69f3": function(module2, exports2, __webpack_require__) {
        var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
        var global = __webpack_require__("da84");
        var isObject2 = __webpack_require__("861d");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var objectHas = __webpack_require__("5135");
        var shared = __webpack_require__("c6cd");
        var sharedKey = __webpack_require__("f772");
        var hiddenKeys = __webpack_require__("d012");
        var WeakMap2 = global.WeakMap;
        var set, get, has;
        var enforce = function(it) {
          return has(it) ? get(it) : set(it, {});
        };
        var getterFor = function(TYPE) {
          return function(it) {
            var state;
            if (!isObject2(it) || (state = get(it)).type !== TYPE) {
              throw TypeError("Incompatible receiver, " + TYPE + " required");
            }
            return state;
          };
        };
        if (NATIVE_WEAK_MAP) {
          var store = shared.state || (shared.state = new WeakMap2());
          var wmget = store.get;
          var wmhas = store.has;
          var wmset = store.set;
          set = function(it, metadata) {
            metadata.facade = it;
            wmset.call(store, it, metadata);
            return metadata;
          };
          get = function(it) {
            return wmget.call(store, it) || {};
          };
          has = function(it) {
            return wmhas.call(store, it);
          };
        } else {
          var STATE = sharedKey("state");
          hiddenKeys[STATE] = true;
          set = function(it, metadata) {
            metadata.facade = it;
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
          };
          get = function(it) {
            return objectHas(it, STATE) ? it[STATE] : {};
          };
          has = function(it) {
            return objectHas(it, STATE);
          };
        }
        module2.exports = {
          set,
          get,
          has,
          enforce,
          getterFor
        };
      },
      "6eeb": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var has = __webpack_require__("5135");
        var setGlobal = __webpack_require__("ce4e");
        var inspectSource = __webpack_require__("8925");
        var InternalStateModule = __webpack_require__("69f3");
        var getInternalState = InternalStateModule.get;
        var enforceInternalState = InternalStateModule.enforce;
        var TEMPLATE = String(String).split("String");
        (module2.exports = function(O, key, value, options) {
          var unsafe = options ? !!options.unsafe : false;
          var simple = options ? !!options.enumerable : false;
          var noTargetGet = options ? !!options.noTargetGet : false;
          var state;
          if (typeof value == "function") {
            if (typeof key == "string" && !has(value, "name")) {
              createNonEnumerableProperty(value, "name", key);
            }
            state = enforceInternalState(value);
            if (!state.source) {
              state.source = TEMPLATE.join(typeof key == "string" ? key : "");
            }
          }
          if (O === global) {
            if (simple)
              O[key] = value;
            else
              setGlobal(key, value);
            return;
          } else if (!unsafe) {
            delete O[key];
          } else if (!noTargetGet && O[key]) {
            simple = true;
          }
          if (simple)
            O[key] = value;
          else
            createNonEnumerableProperty(O, key, value);
        })(Function.prototype, "toString", function toString() {
          return typeof this == "function" && getInternalState(this).source || inspectSource(this);
        });
      },
      "7156": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        var setPrototypeOf = __webpack_require__("d2bb");
        module2.exports = function($this, dummy, Wrapper) {
          var NewTarget, NewTargetPrototype;
          if (setPrototypeOf && typeof (NewTarget = dummy.constructor) == "function" && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
            setPrototypeOf($this, NewTargetPrototype);
          return $this;
        };
      },
      "72f0": function(module2, exports2) {
        function constant(value) {
          return function() {
            return value;
          };
        }
        module2.exports = constant;
      },
      "7418": function(module2, exports2) {
        exports2.f = Object.getOwnPropertySymbols;
      },
      "7839": function(module2, exports2) {
        module2.exports = [
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf"
        ];
      },
      "7b0b": function(module2, exports2, __webpack_require__) {
        var requireObjectCoercible = __webpack_require__("1d80");
        module2.exports = function(argument) {
          return Object(requireObjectCoercible(argument));
        };
      },
      "7c73": function(module2, exports2, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        var defineProperties = __webpack_require__("37e8");
        var enumBugKeys = __webpack_require__("7839");
        var hiddenKeys = __webpack_require__("d012");
        var html = __webpack_require__("1be4");
        var documentCreateElement = __webpack_require__("cc12");
        var sharedKey = __webpack_require__("f772");
        var GT = ">";
        var LT = "<";
        var PROTOTYPE = "prototype";
        var SCRIPT = "script";
        var IE_PROTO = sharedKey("IE_PROTO");
        var EmptyConstructor = function() {
        };
        var scriptTag = function(content) {
          return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
        };
        var NullProtoObjectViaActiveX = function(activeXDocument2) {
          activeXDocument2.write(scriptTag(""));
          activeXDocument2.close();
          var temp = activeXDocument2.parentWindow.Object;
          activeXDocument2 = null;
          return temp;
        };
        var NullProtoObjectViaIFrame = function() {
          var iframe = documentCreateElement("iframe");
          var JS = "java" + SCRIPT + ":";
          var iframeDocument;
          iframe.style.display = "none";
          html.appendChild(iframe);
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag("document.F=Object"));
          iframeDocument.close();
          return iframeDocument.F;
        };
        var activeXDocument;
        var NullProtoObject = function() {
          try {
            activeXDocument = document.domain && new ActiveXObject("htmlfile");
          } catch (error) {
          }
          NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
          var length = enumBugKeys.length;
          while (length--)
            delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
          return NullProtoObject();
        };
        hiddenKeys[IE_PROTO] = true;
        module2.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else
            result = NullProtoObject();
          return Properties === void 0 ? result : defineProperties(result, Properties);
        };
      },
      "7f9a": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var inspectSource = __webpack_require__("8925");
        var WeakMap2 = global.WeakMap;
        module2.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
      },
      "825a": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        module2.exports = function(it) {
          if (!isObject2(it)) {
            throw TypeError(String(it) + " is not an object");
          }
          return it;
        };
      },
      "83ab": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module2.exports = !fails(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      },
      "8418": function(module2, exports2, __webpack_require__) {
        "use strict";
        var toPrimitive = __webpack_require__("c04e");
        var definePropertyModule = __webpack_require__("9bf2");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        module2.exports = function(object, key, value) {
          var propertyKey = toPrimitive(key);
          if (propertyKey in object)
            definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
          else
            object[propertyKey] = value;
        };
      },
      "861d": function(module2, exports2) {
        module2.exports = function(it) {
          return typeof it === "object" ? it !== null : typeof it === "function";
        };
      },
      "8925": function(module2, exports2, __webpack_require__) {
        var store = __webpack_require__("c6cd");
        var functionToString = Function.toString;
        if (typeof store.inspectSource != "function") {
          store.inspectSource = function(it) {
            return functionToString.call(it);
          };
        }
        module2.exports = store.inspectSource;
      },
      "8aa5": function(module2, exports2, __webpack_require__) {
        "use strict";
        var charAt = __webpack_require__("6547").charAt;
        module2.exports = function(S, index, unicode) {
          return index + (unicode ? charAt(S, index).length : 1);
        };
      },
      "8bbf": function(module2, exports2) {
        module2.exports = require_vue();
      },
      "90e3": function(module2, exports2) {
        var id = 0;
        var postfix = Math.random();
        module2.exports = function(key) {
          return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
        };
      },
      "9112": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var definePropertyModule = __webpack_require__("9bf2");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        module2.exports = DESCRIPTORS ? function(object, key, value) {
          return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
        } : function(object, key, value) {
          object[key] = value;
          return object;
        };
      },
      "9263": function(module2, exports2, __webpack_require__) {
        "use strict";
        var regexpFlags = __webpack_require__("ad6d");
        var stickyHelpers = __webpack_require__("9f7f");
        var nativeExec = RegExp.prototype.exec;
        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var UPDATES_LAST_INDEX_WRONG = function() {
          var re1 = /a/;
          var re2 = /b*/g;
          nativeExec.call(re1, "a");
          nativeExec.call(re2, "a");
          return re1.lastIndex !== 0 || re2.lastIndex !== 0;
        }();
        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
        var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
        if (PATCH) {
          patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;
            var sticky = UNSUPPORTED_Y && re.sticky;
            var flags = regexpFlags.call(re);
            var source = re.source;
            var charsAdded = 0;
            var strCopy = str;
            if (sticky) {
              flags = flags.replace("y", "");
              if (flags.indexOf("g") === -1) {
                flags += "g";
              }
              strCopy = String(str).slice(re.lastIndex);
              if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
                source = "(?: " + source + ")";
                strCopy = " " + strCopy;
                charsAdded++;
              }
              reCopy = new RegExp("^(?:" + source + ")", flags);
            }
            if (NPCG_INCLUDED) {
              reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
            }
            if (UPDATES_LAST_INDEX_WRONG)
              lastIndex = re.lastIndex;
            match = nativeExec.call(sticky ? reCopy : re, strCopy);
            if (sticky) {
              if (match) {
                match.input = match.input.slice(charsAdded);
                match[0] = match[0].slice(charsAdded);
                match.index = re.lastIndex;
                re.lastIndex += match[0].length;
              } else
                re.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match) {
              re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
              nativeReplace.call(match[0], reCopy, function() {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === void 0)
                    match[i] = void 0;
                }
              });
            }
            return match;
          };
        }
        module2.exports = patchedExec;
      },
      "94ca": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var replacement = /#|\.prototype\./;
        var isForced = function(feature, detection) {
          var value = data[normalize(feature)];
          return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
        };
        var normalize = isForced.normalize = function(string) {
          return String(string).replace(replacement, ".").toLowerCase();
        };
        var data = isForced.data = {};
        var NATIVE = isForced.NATIVE = "N";
        var POLYFILL = isForced.POLYFILL = "P";
        module2.exports = isForced;
      },
      "99af": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var fails = __webpack_require__("d039");
        var isArray2 = __webpack_require__("e8b5");
        var isObject2 = __webpack_require__("861d");
        var toObject = __webpack_require__("7b0b");
        var toLength = __webpack_require__("50c4");
        var createProperty = __webpack_require__("8418");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var wellKnownSymbol = __webpack_require__("b622");
        var V8_VERSION = __webpack_require__("2d00");
        var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
        var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
          var array = [];
          array[IS_CONCAT_SPREADABLE] = false;
          return array.concat()[0] !== array;
        });
        var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
        var isConcatSpreadable = function(O) {
          if (!isObject2(O))
            return false;
          var spreadable = O[IS_CONCAT_SPREADABLE];
          return spreadable !== void 0 ? !!spreadable : isArray2(O);
        };
        var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
        $({ target: "Array", proto: true, forced: FORCED }, {
          concat: function concat(arg) {
            var O = toObject(this);
            var A = arraySpeciesCreate(O, 0);
            var n = 0;
            var i, k, length, len, E;
            for (i = -1, length = arguments.length; i < length; i++) {
              E = i === -1 ? O : arguments[i];
              if (isConcatSpreadable(E)) {
                len = toLength(E.length);
                if (n + len > MAX_SAFE_INTEGER)
                  throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                for (k = 0; k < len; k++, n++)
                  if (k in E)
                    createProperty(A, n, E[k]);
              } else {
                if (n >= MAX_SAFE_INTEGER)
                  throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                createProperty(A, n++, E);
              }
            }
            A.length = n;
            return A;
          }
        });
      },
      "9bf2": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var IE8_DOM_DEFINE = __webpack_require__("0cfb");
        var anObject = __webpack_require__("825a");
        var toPrimitive = __webpack_require__("c04e");
        var nativeDefineProperty = Object.defineProperty;
        exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return nativeDefineProperty(O, P, Attributes);
            } catch (error) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError("Accessors not supported");
          if ("value" in Attributes)
            O[P] = Attributes.value;
          return O;
        };
      },
      "9e69": function(module2, exports2, __webpack_require__) {
        var root = __webpack_require__("2b3e");
        var Symbol2 = root.Symbol;
        module2.exports = Symbol2;
      },
      "9f7f": function(module2, exports2, __webpack_require__) {
        "use strict";
        var fails = __webpack_require__("d039");
        function RE(s, f) {
          return RegExp(s, f);
        }
        exports2.UNSUPPORTED_Y = fails(function() {
          var re = RE("a", "y");
          re.lastIndex = 2;
          return re.exec("abcd") != null;
        });
        exports2.BROKEN_CARET = fails(function() {
          var re = RE("^r", "gy");
          re.lastIndex = 2;
          return re.exec("str") != null;
        });
      },
      "a15b": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var IndexedObject = __webpack_require__("44ad");
        var toIndexedObject = __webpack_require__("fc6a");
        var arrayMethodIsStrict = __webpack_require__("a640");
        var nativeJoin = [].join;
        var ES3_STRINGS = IndexedObject != Object;
        var STRICT_METHOD = arrayMethodIsStrict("join", ",");
        $({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
          join: function join(separator) {
            return nativeJoin.call(toIndexedObject(this), separator === void 0 ? "," : separator);
          }
        });
      },
      "a2bf": function(module2, exports2, __webpack_require__) {
        "use strict";
        var isArray2 = __webpack_require__("e8b5");
        var toLength = __webpack_require__("50c4");
        var bind = __webpack_require__("0366");
        var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
          var targetIndex = start;
          var sourceIndex = 0;
          var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
          var element;
          while (sourceIndex < sourceLen) {
            if (sourceIndex in source) {
              element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
              if (depth > 0 && isArray2(element)) {
                targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
              } else {
                if (targetIndex >= 9007199254740991)
                  throw TypeError("Exceed the acceptable array length");
                target[targetIndex] = element;
              }
              targetIndex++;
            }
            sourceIndex++;
          }
          return targetIndex;
        };
        module2.exports = flattenIntoArray;
      },
      "a434": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var toInteger = __webpack_require__("a691");
        var toLength = __webpack_require__("50c4");
        var toObject = __webpack_require__("7b0b");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var createProperty = __webpack_require__("8418");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
        var USES_TO_LENGTH = arrayMethodUsesToLength("splice", { ACCESSORS: true, 0: 0, 1: 2 });
        var max = Math.max;
        var min = Math.min;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          splice: function splice(start, deleteCount) {
            var O = toObject(this);
            var len = toLength(O.length);
            var actualStart = toAbsoluteIndex(start, len);
            var argumentsLength = arguments.length;
            var insertCount, actualDeleteCount, A, k, from, to;
            if (argumentsLength === 0) {
              insertCount = actualDeleteCount = 0;
            } else if (argumentsLength === 1) {
              insertCount = 0;
              actualDeleteCount = len - actualStart;
            } else {
              insertCount = argumentsLength - 2;
              actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
            }
            if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
              throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
            }
            A = arraySpeciesCreate(O, actualDeleteCount);
            for (k = 0; k < actualDeleteCount; k++) {
              from = actualStart + k;
              if (from in O)
                createProperty(A, k, O[from]);
            }
            A.length = actualDeleteCount;
            if (insertCount < actualDeleteCount) {
              for (k = actualStart; k < len - actualDeleteCount; k++) {
                from = k + actualDeleteCount;
                to = k + insertCount;
                if (from in O)
                  O[to] = O[from];
                else
                  delete O[to];
              }
              for (k = len; k > len - actualDeleteCount + insertCount; k--)
                delete O[k - 1];
            } else if (insertCount > actualDeleteCount) {
              for (k = len - actualDeleteCount; k > actualStart; k--) {
                from = k + actualDeleteCount - 1;
                to = k + insertCount - 1;
                if (from in O)
                  O[to] = O[from];
                else
                  delete O[to];
              }
            }
            for (k = 0; k < insertCount; k++) {
              O[k + actualStart] = arguments[k + 2];
            }
            O.length = len - actualDeleteCount + insertCount;
            return A;
          }
        });
      },
      "a623": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $every = __webpack_require__("b727").every;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var STRICT_METHOD = arrayMethodIsStrict("every");
        var USES_TO_LENGTH = arrayMethodUsesToLength("every");
        $({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
          every: function every(callbackfn) {
            return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "a640": function(module2, exports2, __webpack_require__) {
        "use strict";
        var fails = __webpack_require__("d039");
        module2.exports = function(METHOD_NAME, argument) {
          var method = [][METHOD_NAME];
          return !!method && fails(function() {
            method.call(null, argument || function() {
              throw 1;
            }, 1);
          });
        };
      },
      "a691": function(module2, exports2) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module2.exports = function(argument) {
          return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
        };
      },
      "a9e3": function(module2, exports2, __webpack_require__) {
        "use strict";
        var DESCRIPTORS = __webpack_require__("83ab");
        var global = __webpack_require__("da84");
        var isForced = __webpack_require__("94ca");
        var redefine = __webpack_require__("6eeb");
        var has = __webpack_require__("5135");
        var classof = __webpack_require__("c6b6");
        var inheritIfRequired = __webpack_require__("7156");
        var toPrimitive = __webpack_require__("c04e");
        var fails = __webpack_require__("d039");
        var create = __webpack_require__("7c73");
        var getOwnPropertyNames = __webpack_require__("241c").f;
        var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var defineProperty = __webpack_require__("9bf2").f;
        var trim = __webpack_require__("58a8").trim;
        var NUMBER = "Number";
        var NativeNumber = global[NUMBER];
        var NumberPrototype = NativeNumber.prototype;
        var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;
        var toNumber = function(argument) {
          var it = toPrimitive(argument, false);
          var first, third, radix, maxCode, digits, length, index, code;
          if (typeof it == "string" && it.length > 2) {
            it = trim(it);
            first = it.charCodeAt(0);
            if (first === 43 || first === 45) {
              third = it.charCodeAt(2);
              if (third === 88 || third === 120)
                return NaN;
            } else if (first === 48) {
              switch (it.charCodeAt(1)) {
                case 66:
                case 98:
                  radix = 2;
                  maxCode = 49;
                  break;
                case 79:
                case 111:
                  radix = 8;
                  maxCode = 55;
                  break;
                default:
                  return +it;
              }
              digits = it.slice(2);
              length = digits.length;
              for (index = 0; index < length; index++) {
                code = digits.charCodeAt(index);
                if (code < 48 || code > maxCode)
                  return NaN;
              }
              return parseInt(digits, radix);
            }
          }
          return +it;
        };
        if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
          var NumberWrapper = function Number2(value) {
            var it = arguments.length < 1 ? 0 : value;
            var dummy = this;
            return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {
              NumberPrototype.valueOf.call(dummy);
            }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
          };
          for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","), j = 0, key; keys.length > j; j++) {
            if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
              defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
            }
          }
          NumberWrapper.prototype = NumberPrototype;
          NumberPrototype.constructor = NumberWrapper;
          redefine(global, NUMBER, NumberWrapper);
        }
      },
      "ac1f": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var exec = __webpack_require__("9263");
        $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
          exec
        });
      },
      "ad6d": function(module2, exports2, __webpack_require__) {
        "use strict";
        var anObject = __webpack_require__("825a");
        module2.exports = function() {
          var that = anObject(this);
          var result = "";
          if (that.global)
            result += "g";
          if (that.ignoreCase)
            result += "i";
          if (that.multiline)
            result += "m";
          if (that.dotAll)
            result += "s";
          if (that.unicode)
            result += "u";
          if (that.sticky)
            result += "y";
          return result;
        };
      },
      "ae40": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var fails = __webpack_require__("d039");
        var has = __webpack_require__("5135");
        var defineProperty = Object.defineProperty;
        var cache = {};
        var thrower = function(it) {
          throw it;
        };
        module2.exports = function(METHOD_NAME, options) {
          if (has(cache, METHOD_NAME))
            return cache[METHOD_NAME];
          if (!options)
            options = {};
          var method = [][METHOD_NAME];
          var ACCESSORS = has(options, "ACCESSORS") ? options.ACCESSORS : false;
          var argument0 = has(options, 0) ? options[0] : thrower;
          var argument1 = has(options, 1) ? options[1] : void 0;
          return cache[METHOD_NAME] = !!method && !fails(function() {
            if (ACCESSORS && !DESCRIPTORS)
              return true;
            var O = { length: -1 };
            if (ACCESSORS)
              defineProperty(O, 1, { enumerable: true, get: thrower });
            else
              O[1] = 1;
            method.call(O, argument0, argument1);
          });
        };
      },
      "b041": function(module2, exports2, __webpack_require__) {
        "use strict";
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var classof = __webpack_require__("f5df");
        module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
          return "[object " + classof(this) + "]";
        };
      },
      "b047": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("1a8c"), now = __webpack_require__("408c"), toNumber = __webpack_require__("b4b0");
        var FUNC_ERROR_TEXT = "Expected a function";
        var nativeMax = Math.max, nativeMin = Math.min;
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = void 0;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = void 0;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = void 0;
            return result;
          }
          function cancel() {
            if (timerId !== void 0) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = void 0;
          }
          function flush() {
            return timerId === void 0 ? result : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === void 0) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === void 0) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        module2.exports = debounce;
      },
      "b4b0": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("1a8c"), isSymbol2 = __webpack_require__("ffd6");
        var NAN = 0 / 0;
        var reTrim = /^\s+|\s+$/g;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsOctal = /^0o[0-7]+$/i;
        var freeParseInt = parseInt;
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, "");
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        module2.exports = toNumber;
      },
      "b622": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var shared = __webpack_require__("5692");
        var has = __webpack_require__("5135");
        var uid = __webpack_require__("90e3");
        var NATIVE_SYMBOL = __webpack_require__("4930");
        var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
        var WellKnownSymbolsStore = shared("wks");
        var Symbol2 = global.Symbol;
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
        module2.exports = function(name) {
          if (!has(WellKnownSymbolsStore, name)) {
            if (NATIVE_SYMBOL && has(Symbol2, name))
              WellKnownSymbolsStore[name] = Symbol2[name];
            else
              WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
          }
          return WellKnownSymbolsStore[name];
        };
      },
      "b64b": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var toObject = __webpack_require__("7b0b");
        var nativeKeys = __webpack_require__("df75");
        var fails = __webpack_require__("d039");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeKeys(1);
        });
        $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
          keys: function keys(it) {
            return nativeKeys(toObject(it));
          }
        });
      },
      "b727": function(module2, exports2, __webpack_require__) {
        var bind = __webpack_require__("0366");
        var IndexedObject = __webpack_require__("44ad");
        var toObject = __webpack_require__("7b0b");
        var toLength = __webpack_require__("50c4");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var push = [].push;
        var createMethod = function(TYPE) {
          var IS_MAP = TYPE == 1;
          var IS_FILTER = TYPE == 2;
          var IS_SOME = TYPE == 3;
          var IS_EVERY = TYPE == 4;
          var IS_FIND_INDEX = TYPE == 6;
          var IS_FILTER_OUT = TYPE == 7;
          var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
          return function($this, callbackfn, that, specificCreate) {
            var O = toObject($this);
            var self2 = IndexedObject(O);
            var boundFunction = bind(callbackfn, that, 3);
            var length = toLength(self2.length);
            var index = 0;
            var create = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : void 0;
            var value, result;
            for (; length > index; index++)
              if (NO_HOLES || index in self2) {
                value = self2[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                  if (IS_MAP)
                    target[index] = result;
                  else if (result)
                    switch (TYPE) {
                      case 3:
                        return true;
                      case 5:
                        return value;
                      case 6:
                        return index;
                      case 2:
                        push.call(target, value);
                    }
                  else
                    switch (TYPE) {
                      case 4:
                        return false;
                      case 7:
                        push.call(target, value);
                    }
                }
              }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
          };
        };
        module2.exports = {
          forEach: createMethod(0),
          map: createMethod(1),
          filter: createMethod(2),
          some: createMethod(3),
          every: createMethod(4),
          find: createMethod(5),
          findIndex: createMethod(6),
          filterOut: createMethod(7)
        };
      },
      "bcdf": function(module2, exports2) {
        function noop() {
        }
        module2.exports = noop;
      },
      "c04e": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        module2.exports = function(input, PREFERRED_STRING) {
          if (!isObject2(input))
            return input;
          var fn, val;
          if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input)))
            return val;
          if (typeof (fn = input.valueOf) == "function" && !isObject2(val = fn.call(input)))
            return val;
          if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input)))
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      "c430": function(module2, exports2) {
        module2.exports = false;
      },
      "c6b6": function(module2, exports2) {
        var toString = {}.toString;
        module2.exports = function(it) {
          return toString.call(it).slice(8, -1);
        };
      },
      "c6cd": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var setGlobal = __webpack_require__("ce4e");
        var SHARED = "__core-js_shared__";
        var store = global[SHARED] || setGlobal(SHARED, {});
        module2.exports = store;
      },
      "c8ba": function(module2, exports2) {
        var g;
        g = function() {
          return this;
        }();
        try {
          g = g || new Function("return this")();
        } catch (e) {
          if (typeof window === "object")
            g = window;
        }
        module2.exports = g;
      },
      "c8d2": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var whitespaces = __webpack_require__("5899");
        var non = "\u200B\x85\u180E";
        module2.exports = function(METHOD_NAME) {
          return fails(function() {
            return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
          });
        };
      },
      "c975": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $indexOf = __webpack_require__("4d64").indexOf;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var nativeIndexOf = [].indexOf;
        var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
        var STRICT_METHOD = arrayMethodIsStrict("indexOf");
        var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
        $({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
          indexOf: function indexOf(searchElement) {
            return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "ca84": function(module2, exports2, __webpack_require__) {
        var has = __webpack_require__("5135");
        var toIndexedObject = __webpack_require__("fc6a");
        var indexOf = __webpack_require__("4d64").indexOf;
        var hiddenKeys = __webpack_require__("d012");
        module2.exports = function(object, names) {
          var O = toIndexedObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O)
            !has(hiddenKeys, key) && has(O, key) && result.push(key);
          while (names.length > i)
            if (has(O, key = names[i++])) {
              ~indexOf(result, key) || result.push(key);
            }
          return result;
        };
      },
      "cc12": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isObject2 = __webpack_require__("861d");
        var document2 = global.document;
        var EXISTS = isObject2(document2) && isObject2(document2.createElement);
        module2.exports = function(it) {
          return EXISTS ? document2.createElement(it) : {};
        };
      },
      "cd9d": function(module2, exports2) {
        function identity(value) {
          return value;
        }
        module2.exports = identity;
      },
      "ce4e": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var createNonEnumerableProperty = __webpack_require__("9112");
        module2.exports = function(key, value) {
          try {
            createNonEnumerableProperty(global, key, value);
          } catch (error) {
            global[key] = value;
          }
          return value;
        };
      },
      "d012": function(module2, exports2) {
        module2.exports = {};
      },
      "d039": function(module2, exports2) {
        module2.exports = function(exec) {
          try {
            return !!exec();
          } catch (error) {
            return true;
          }
        };
      },
      "d066": function(module2, exports2, __webpack_require__) {
        var path = __webpack_require__("428f");
        var global = __webpack_require__("da84");
        var aFunction = function(variable) {
          return typeof variable == "function" ? variable : void 0;
        };
        module2.exports = function(namespace, method) {
          return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
        };
      },
      "d15f": function(module2, exports2, __webpack_require__) {
      },
      "d1e7": function(module2, exports2, __webpack_require__) {
        "use strict";
        var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
        exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
          var descriptor = getOwnPropertyDescriptor(this, V);
          return !!descriptor && descriptor.enumerable;
        } : nativePropertyIsEnumerable;
      },
      "d2bb": function(module2, exports2, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        var aPossiblePrototype = __webpack_require__("3bbe");
        module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var CORRECT_SETTER = false;
          var test = {};
          var setter;
          try {
            setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
            setter.call(test, []);
            CORRECT_SETTER = test instanceof Array;
          } catch (error) {
          }
          return function setPrototypeOf(O, proto) {
            anObject(O);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER)
              setter.call(O, proto);
            else
              O.__proto__ = proto;
            return O;
          };
        }() : void 0);
      },
      "d3b7": function(module2, exports2, __webpack_require__) {
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var redefine = __webpack_require__("6eeb");
        var toString = __webpack_require__("b041");
        if (!TO_STRING_TAG_SUPPORT) {
          redefine(Object.prototype, "toString", toString, { unsafe: true });
        }
      },
      "d58f": function(module2, exports2, __webpack_require__) {
        var aFunction = __webpack_require__("1c0b");
        var toObject = __webpack_require__("7b0b");
        var IndexedObject = __webpack_require__("44ad");
        var toLength = __webpack_require__("50c4");
        var createMethod = function(IS_RIGHT) {
          return function(that, callbackfn, argumentsLength, memo) {
            aFunction(callbackfn);
            var O = toObject(that);
            var self2 = IndexedObject(O);
            var length = toLength(O.length);
            var index = IS_RIGHT ? length - 1 : 0;
            var i = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2)
              while (true) {
                if (index in self2) {
                  memo = self2[index];
                  index += i;
                  break;
                }
                index += i;
                if (IS_RIGHT ? index < 0 : length <= index) {
                  throw TypeError("Reduce of empty array with no initial value");
                }
              }
            for (; IS_RIGHT ? index >= 0 : length > index; index += i)
              if (index in self2) {
                memo = callbackfn(memo, self2[index], index, O);
              }
            return memo;
          };
        };
        module2.exports = {
          left: createMethod(false),
          right: createMethod(true)
        };
      },
      "d784": function(module2, exports2, __webpack_require__) {
        "use strict";
        __webpack_require__("ac1f");
        var redefine = __webpack_require__("6eeb");
        var fails = __webpack_require__("d039");
        var wellKnownSymbol = __webpack_require__("b622");
        var regexpExec = __webpack_require__("9263");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var SPECIES = wellKnownSymbol("species");
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          var re = /./;
          re.exec = function() {
            var result = [];
            result.groups = { a: "7" };
            return result;
          };
          return "".replace(re, "$<a>") !== "7";
        });
        var REPLACE_KEEPS_$0 = function() {
          return "a".replace(/./, "$0") === "$0";
        }();
        var REPLACE = wellKnownSymbol("replace");
        var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
          if (/./[REPLACE]) {
            return /./[REPLACE]("a", "$0") === "";
          }
          return false;
        }();
        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
          var re = /(?:)/;
          var originalExec = re.exec;
          re.exec = function() {
            return originalExec.apply(this, arguments);
          };
          var result = "ab".split(re);
          return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
        });
        module2.exports = function(KEY, length, exec, sham) {
          var SYMBOL = wellKnownSymbol(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function() {
            var O = {};
            O[SYMBOL] = function() {
              return 7;
            };
            return ""[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
            var execCalled = false;
            var re = /a/;
            if (KEY === "split") {
              re = {};
              re.constructor = {};
              re.constructor[SPECIES] = function() {
                return re;
              };
              re.flags = "";
              re[SYMBOL] = /./[SYMBOL];
            }
            re.exec = function() {
              execCalled = true;
              return null;
            };
            re[SYMBOL]("");
            return !execCalled;
          });
          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
            var nativeRegExpMethod = /./[SYMBOL];
            var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
              if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                }
                return { done: true, value: nativeMethod.call(str, regexp, arg2) };
              }
              return { done: false };
            }, {
              REPLACE_KEEPS_$0,
              REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
            });
            var stringMethod = methods[0];
            var regexMethod = methods[1];
            redefine(String.prototype, KEY, stringMethod);
            redefine(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
              return regexMethod.call(string, this, arg);
            } : function(string) {
              return regexMethod.call(string, this);
            });
          }
          if (sham)
            createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
        };
      },
      "d81d": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $map = __webpack_require__("b727").map;
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
        var USES_TO_LENGTH = arrayMethodUsesToLength("map");
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          map: function map(callbackfn) {
            return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "da84": function(module2, exports2, __webpack_require__) {
        (function(global) {
          var check = function(it) {
            return it && it.Math == Math && it;
          };
          module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        }).call(this, __webpack_require__("c8ba"));
      },
      "df75": function(module2, exports2, __webpack_require__) {
        var internalObjectKeys = __webpack_require__("ca84");
        var enumBugKeys = __webpack_require__("7839");
        module2.exports = Object.keys || function keys(O) {
          return internalObjectKeys(O, enumBugKeys);
        };
      },
      "e0ef": function(module2, exports2, __webpack_require__) {
        var toInteger = __webpack_require__("4b17");
        var FUNC_ERROR_TEXT = "Expected a function";
        function before(n, func) {
          var result;
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = void 0;
            }
            return result;
          };
        }
        module2.exports = before;
      },
      "e163": function(module2, exports2, __webpack_require__) {
        var has = __webpack_require__("5135");
        var toObject = __webpack_require__("7b0b");
        var sharedKey = __webpack_require__("f772");
        var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
        var IE_PROTO = sharedKey("IE_PROTO");
        var ObjectPrototype = Object.prototype;
        module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
          O = toObject(O);
          if (has(O, IE_PROTO))
            return O[IE_PROTO];
          if (typeof O.constructor == "function" && O instanceof O.constructor) {
            return O.constructor.prototype;
          }
          return O instanceof Object ? ObjectPrototype : null;
        };
      },
      "e177": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module2.exports = !fails(function() {
          function F() {
          }
          F.prototype.constructor = null;
          return Object.getPrototypeOf(new F()) !== F.prototype;
        });
      },
      "e893": function(module2, exports2, __webpack_require__) {
        var has = __webpack_require__("5135");
        var ownKeys = __webpack_require__("56ef");
        var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
        var definePropertyModule = __webpack_require__("9bf2");
        module2.exports = function(target, source) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!has(target, key))
              defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        };
      },
      "e8b5": function(module2, exports2, __webpack_require__) {
        var classof = __webpack_require__("c6b6");
        module2.exports = Array.isArray || function isArray2(arg) {
          return classof(arg) == "Array";
        };
      },
      "f5df": function(module2, exports2, __webpack_require__) {
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var classofRaw = __webpack_require__("c6b6");
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var CORRECT_ARGUMENTS = classofRaw(function() {
          return arguments;
        }()) == "Arguments";
        var tryGet = function(it, key) {
          try {
            return it[key];
          } catch (error) {
          }
        };
        module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
          var O, tag, result;
          return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
        };
      },
      "f772": function(module2, exports2, __webpack_require__) {
        var shared = __webpack_require__("5692");
        var uid = __webpack_require__("90e3");
        var keys = shared("keys");
        module2.exports = function(key) {
          return keys[key] || (keys[key] = uid(key));
        };
      },
      "fb15": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "Treeselect", function() {
          return Treeselect;
        });
        __webpack_require__.d(__webpack_exports__, "treeselectMixin", function() {
          return treeselectMixin;
        });
        __webpack_require__.d(__webpack_exports__, "LOAD_ROOT_OPTIONS", function() {
          return LOAD_ROOT_OPTIONS;
        });
        __webpack_require__.d(__webpack_exports__, "LOAD_CHILDREN_OPTIONS", function() {
          return LOAD_CHILDREN_OPTIONS;
        });
        __webpack_require__.d(__webpack_exports__, "ASYNC_SEARCH", function() {
          return ASYNC_SEARCH;
        });
        if (typeof window !== "undefined") {
          var currentScript = window.document.currentScript;
          if (false) {
            var getCurrentScript;
          }
          var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          if (src) {
            __webpack_require__.p = src[1];
          }
        }
        var setPublicPath = null;
        var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
        function Treeselectvue_type_template_id_5905dd6c_render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_HiddenFields = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("HiddenFields");
          var _component_Control = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("Control");
          var _component_MenuPortal = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("MenuPortal");
          var _component_Menu = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("Menu");
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", {
            ref: "wrapper",
            class: _ctx.wrapperClass
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(_component_HiddenFields), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(_component_Control, {
            ref: "control"
          }, null, 512), _ctx.appendToBody ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])(_component_MenuPortal, {
            key: 0,
            ref: "portal"
          }, null, 512)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])(_component_Menu, {
            key: 1,
            ref: "menu"
          }, null, 512))], 2);
        }
        var es_array_concat = __webpack_require__("99af");
        var es_array_every = __webpack_require__("a623");
        var es_array_filter = __webpack_require__("4de4");
        var es_array_flat = __webpack_require__("0481");
        var es_array_for_each = __webpack_require__("4160");
        var es_array_index_of = __webpack_require__("c975");
        var es_array_map = __webpack_require__("d81d");
        var es_array_reduce = __webpack_require__("13d5");
        var es_array_slice = __webpack_require__("fb6a");
        var es_array_some = __webpack_require__("45fc");
        var es_array_sort = __webpack_require__("4e82");
        var es_array_unscopables_flat = __webpack_require__("4069");
        var es_number_constructor = __webpack_require__("a9e3");
        var es_regexp_exec = __webpack_require__("ac1f");
        var es_string_replace = __webpack_require__("5319");
        var es_string_split = __webpack_require__("1276");
        var es_string_trim = __webpack_require__("498a");
        var web_dom_collections_for_each = __webpack_require__("159b");
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray(o, minLen);
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return _arrayLikeToArray(arr);
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        var fuzzysearch = __webpack_require__("2e39");
        var fuzzysearch_default = __webpack_require__.n(fuzzysearch);
        function isNaN_isNaN(x) {
          return x !== x;
        }
        function includes(arrOrStr, elem) {
          return arrOrStr.indexOf(elem) !== -1;
        }
        var constant = __webpack_require__("72f0");
        var constant_default = __webpack_require__.n(constant);
        var identity = __webpack_require__("cd9d");
        var identity_default = __webpack_require__.n(identity);
        var createMap = function createMap2() {
          return /* @__PURE__ */ Object.create(null);
        };
        function quickDiff(arrA, arrB) {
          if (arrA.length !== arrB.length)
            return true;
          for (var i = 0; i < arrA.length; i++) {
            if (arrA[i] !== arrB[i])
              return true;
          }
          return false;
        }
        var noop = __webpack_require__("bcdf");
        var noop_default = __webpack_require__.n(noop);
        var warning = true ? noop_default.a : void 0;
        function find(arr, predicate, ctx) {
          for (var i = 0, len = arr.length; i < len; i++) {
            if (predicate.call(ctx, arr[i], i, arr))
              return arr[i];
          }
          return void 0;
        }
        function onLeftClick(mouseDownHandler) {
          return function onMouseDown(evt) {
            if (evt.type === "mousedown" && evt.button === 0) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              mouseDownHandler.call.apply(mouseDownHandler, [this, evt].concat(args));
            }
          };
        }
        function scrollIntoView($scrollingEl, $focusedEl) {
          var scrollingReact = $scrollingEl.getBoundingClientRect();
          var focusedRect = $focusedEl.getBoundingClientRect();
          var overScroll = $focusedEl.offsetHeight / 3;
          if (focusedRect.bottom + overScroll > scrollingReact.bottom) {
            $scrollingEl.scrollTop = Math.min($focusedEl.offsetTop + $focusedEl.clientHeight - $scrollingEl.offsetHeight + overScroll, $scrollingEl.scrollHeight);
          } else if (focusedRect.top - overScroll < scrollingReact.top) {
            $scrollingEl.scrollTop = Math.max($focusedEl.offsetTop - overScroll, 0);
          }
        }
        var lodash_last = __webpack_require__("4416");
        var last_default = __webpack_require__.n(lodash_last);
        var once = __webpack_require__("1d92");
        var once_default = __webpack_require__.n(once);
        var is_promise = __webpack_require__("2655");
        var is_promise_default = __webpack_require__.n(is_promise);
        var es_array_splice = __webpack_require__("a434");
        function removeFromArray(arr, elem) {
          var idx = arr.indexOf(elem);
          if (idx !== -1)
            arr.splice(idx, 1);
        }
        var NO_PARENT_NODE = null;
        var UNCHECKED = 0;
        var INDETERMINATE = 1;
        var CHECKED = 2;
        var ALL_CHILDREN = "ALL_CHILDREN";
        var ALL_DESCENDANTS = "ALL_DESCENDANTS";
        var LEAF_CHILDREN = "LEAF_CHILDREN";
        var LEAF_DESCENDANTS = "LEAF_DESCENDANTS";
        var LOAD_ROOT_OPTIONS = "LOAD_ROOT_OPTIONS";
        var LOAD_CHILDREN_OPTIONS = "LOAD_CHILDREN_OPTIONS";
        var ASYNC_SEARCH = "ASYNC_SEARCH";
        var ALL = "ALL";
        var BRANCH_PRIORITY = "BRANCH_PRIORITY";
        var LEAF_PRIORITY = "LEAF_PRIORITY";
        var ALL_WITH_INDETERMINATE = "ALL_WITH_INDETERMINATE";
        var ORDER_SELECTED = "ORDER_SELECTED";
        var LEVEL = "LEVEL";
        var INDEX = "INDEX";
        var KEY_CODES = {
          BACKSPACE: 8,
          ENTER: 13,
          ESCAPE: 27,
          END: 35,
          HOME: 36,
          ARROW_LEFT: 37,
          ARROW_UP: 38,
          ARROW_RIGHT: 39,
          ARROW_DOWN: 40,
          DELETE: 46
        };
        var INPUT_DEBOUNCE_DELAY = false ? void 0 : 200;
        var MIN_INPUT_WIDTH = 5;
        var MENU_BUFFER = 40;
        function sortValueByIndex(a, b) {
          var i = 0;
          do {
            if (a.level < i)
              return -1;
            if (b.level < i)
              return 1;
            if (a.index[i] !== b.index[i])
              return a.index[i] - b.index[i];
            i++;
          } while (true);
        }
        function sortValueByLevel(a, b) {
          return a.level === b.level ? sortValueByIndex(a, b) : a.level - b.level;
        }
        function createAsyncOptionsStates() {
          return {
            isLoaded: false,
            isLoading: false,
            loadingError: ""
          };
        }
        function stringifyOptionPropValue(value) {
          if (typeof value === "string")
            return value;
          if (typeof value === "number" && !isNaN_isNaN(value))
            return value + "";
          return "";
        }
        function match(enableFuzzyMatch, needle, haystack) {
          return enableFuzzyMatch ? fuzzysearch_default()(needle, haystack) : includes(haystack, needle);
        }
        function getErrorMessage(err) {
          return err.message || String(err);
        }
        var instanceId = 0;
        var treeselectMixin = {
          provide: function provide() {
            return {
              instance: this
            };
          },
          props: {
            allowClearingDisabled: {
              type: Boolean,
              default: false
            },
            allowSelectingDisabledDescendants: {
              type: Boolean,
              default: false
            },
            alwaysOpen: {
              type: Boolean,
              default: false
            },
            appendToBody: {
              type: Boolean,
              default: false
            },
            async: {
              type: Boolean,
              default: false
            },
            autoFocus: {
              type: Boolean,
              default: false
            },
            autoLoadRootOptions: {
              type: Boolean,
              default: true
            },
            autoDeselectAncestors: {
              type: Boolean,
              default: false
            },
            autoDeselectDescendants: {
              type: Boolean,
              default: false
            },
            autoSelectAncestors: {
              type: Boolean,
              default: false
            },
            autoSelectDescendants: {
              type: Boolean,
              default: false
            },
            backspaceRemoves: {
              type: Boolean,
              default: true
            },
            beforeClearAll: {
              type: Function,
              default: constant_default()(true)
            },
            branchNodesFirst: {
              type: Boolean,
              default: false
            },
            cacheOptions: {
              type: Boolean,
              default: true
            },
            clearable: {
              type: Boolean,
              default: true
            },
            clearAllText: {
              type: String,
              default: "Clear all"
            },
            clearOnSelect: {
              type: Boolean,
              default: false
            },
            clearValueText: {
              type: String,
              default: "Clear value"
            },
            closeOnSelect: {
              type: Boolean,
              default: true
            },
            defaultExpandLevel: {
              type: Number,
              default: 0
            },
            defaultOptions: {
              default: false
            },
            deleteRemoves: {
              type: Boolean,
              default: true
            },
            delimiter: {
              type: String,
              default: ","
            },
            flattenSearchResults: {
              type: Boolean,
              default: false
            },
            disableBranchNodes: {
              type: Boolean,
              default: false
            },
            disabled: {
              type: Boolean,
              default: false
            },
            disableFuzzyMatching: {
              type: Boolean,
              default: false
            },
            flat: {
              type: Boolean,
              default: false
            },
            instanceId: {
              default: function _default() {
                return "".concat(instanceId++, "$$");
              },
              type: [String, Number]
            },
            joinValues: {
              type: Boolean,
              default: false
            },
            limit: {
              type: Number,
              default: Infinity
            },
            limitText: {
              type: Function,
              default: function limitTextDefault(count) {
                return "and ".concat(count, " more");
              }
            },
            loadingText: {
              type: String,
              default: "Loading..."
            },
            loadOptions: {
              type: Function
            },
            matchKeys: {
              type: Array,
              default: constant_default()(["label"])
            },
            maxHeight: {
              type: Number,
              default: 300
            },
            multiple: {
              type: Boolean,
              default: false
            },
            name: {
              type: String
            },
            noChildrenText: {
              type: String,
              default: "No sub-options."
            },
            noOptionsText: {
              type: String,
              default: "No options available."
            },
            noResultsText: {
              type: String,
              default: "No results found..."
            },
            normalizer: {
              type: Function,
              default: identity_default.a
            },
            openDirection: {
              type: String,
              default: "auto",
              validator: function validator(value) {
                var acceptableValues = ["auto", "top", "bottom", "above", "below"];
                return includes(acceptableValues, value);
              }
            },
            openOnClick: {
              type: Boolean,
              default: true
            },
            openOnFocus: {
              type: Boolean,
              default: false
            },
            options: {
              type: Array
            },
            placeholder: {
              type: String,
              default: "Select..."
            },
            required: {
              type: Boolean,
              default: false
            },
            retryText: {
              type: String,
              default: "Retry?"
            },
            retryTitle: {
              type: String,
              default: "Click to retry"
            },
            searchable: {
              type: Boolean,
              default: true
            },
            searchNested: {
              type: Boolean,
              default: false
            },
            searchPromptText: {
              type: String,
              default: "Type to search..."
            },
            showCount: {
              type: Boolean,
              default: false
            },
            showCountOf: {
              type: String,
              default: ALL_CHILDREN,
              validator: function validator(value) {
                var acceptableValues = [ALL_CHILDREN, ALL_DESCENDANTS, LEAF_CHILDREN, LEAF_DESCENDANTS];
                return includes(acceptableValues, value);
              }
            },
            showCountOnSearch: null,
            sortValueBy: {
              type: String,
              default: ORDER_SELECTED,
              validator: function validator(value) {
                var acceptableValues = [ORDER_SELECTED, LEVEL, INDEX];
                return includes(acceptableValues, value);
              }
            },
            tabIndex: {
              type: Number,
              default: 0
            },
            modelValue: null,
            valueConsistsOf: {
              type: String,
              default: BRANCH_PRIORITY,
              validator: function validator(value) {
                var acceptableValues = [ALL, BRANCH_PRIORITY, LEAF_PRIORITY, ALL_WITH_INDETERMINATE];
                return includes(acceptableValues, value);
              }
            },
            valueFormat: {
              type: String,
              default: "id"
            },
            zIndex: {
              type: [Number, String],
              default: 999
            }
          },
          data: function data() {
            return {
              trigger: {
                isFocused: false,
                searchQuery: ""
              },
              menu: {
                isOpen: false,
                current: null,
                lastScrollPosition: 0,
                placement: "bottom"
              },
              forest: {
                normalizedOptions: [],
                nodeMap: createMap(),
                checkedStateMap: createMap(),
                selectedNodeIds: this.extractCheckedNodeIdsFromValue(),
                selectedNodeMap: createMap()
              },
              rootOptionsStates: createAsyncOptionsStates(),
              localSearch: {
                active: false,
                noResults: true,
                countMap: createMap()
              },
              remoteSearch: createMap()
            };
          },
          computed: {
            selectedNodes: function selectedNodes() {
              return this.forest.selectedNodeIds.map(this.getNode);
            },
            internalValue: function internalValue() {
              var _this = this;
              var internalValue2;
              if (this.single || this.flat || this.disableBranchNodes || this.valueConsistsOf === ALL) {
                internalValue2 = this.forest.selectedNodeIds.slice();
              } else if (this.valueConsistsOf === BRANCH_PRIORITY) {
                internalValue2 = this.forest.selectedNodeIds.filter(function(id) {
                  var node = _this.getNode(id);
                  if (node.isRootNode)
                    return true;
                  return !_this.isSelected(node.parentNode);
                });
              } else if (this.valueConsistsOf === LEAF_PRIORITY) {
                internalValue2 = this.forest.selectedNodeIds.filter(function(id) {
                  var node = _this.getNode(id);
                  if (node.isLeaf)
                    return true;
                  return node.children.length === 0;
                });
              } else if (this.valueConsistsOf === ALL_WITH_INDETERMINATE) {
                var _internalValue;
                var indeterminateNodeIds = [];
                internalValue2 = this.forest.selectedNodeIds.slice();
                this.selectedNodes.forEach(function(selectedNode) {
                  selectedNode.ancestors.forEach(function(ancestor) {
                    if (includes(indeterminateNodeIds, ancestor.id))
                      return;
                    if (includes(internalValue2, ancestor.id))
                      return;
                    indeterminateNodeIds.push(ancestor.id);
                  });
                });
                (_internalValue = internalValue2).push.apply(_internalValue, indeterminateNodeIds);
              }
              if (this.sortValueBy === LEVEL) {
                internalValue2.sort(function(a, b) {
                  return sortValueByLevel(_this.getNode(a), _this.getNode(b));
                });
              } else if (this.sortValueBy === INDEX) {
                internalValue2.sort(function(a, b) {
                  return sortValueByIndex(_this.getNode(a), _this.getNode(b));
                });
              }
              return internalValue2;
            },
            hasValue: function hasValue() {
              return this.internalValue.length > 0;
            },
            single: function single() {
              return !this.multiple;
            },
            visibleOptionIds: function visibleOptionIds() {
              var _this2 = this;
              var visibleOptionIds2 = [];
              this.traverseAllNodesByIndex(function(node) {
                if (!_this2.localSearch.active || _this2.shouldOptionBeIncludedInSearchResult(node)) {
                  visibleOptionIds2.push(node.id);
                }
                if (node.isBranch && !_this2.shouldExpand(node)) {
                  return false;
                }
              });
              return visibleOptionIds2;
            },
            hasVisibleOptions: function hasVisibleOptions() {
              return this.visibleOptionIds.length !== 0;
            },
            showCountOnSearchComputed: function showCountOnSearchComputed() {
              return typeof this.showCountOnSearch === "boolean" ? this.showCountOnSearch : this.showCount;
            },
            hasBranchNodes: function hasBranchNodes() {
              return this.forest.normalizedOptions.some(function(rootNode) {
                return rootNode.isBranch;
              });
            },
            shouldFlattenOptions: function shouldFlattenOptions() {
              return this.localSearch.active && this.flattenSearchResults;
            }
          },
          watch: {
            alwaysOpen: function alwaysOpen(newValue) {
              if (newValue)
                this.openMenu();
              else
                this.closeMenu();
            },
            branchNodesFirst: function branchNodesFirst() {
              this.initialize();
            },
            disabled: function disabled(newValue) {
              if (newValue && this.menu.isOpen)
                this.closeMenu();
              else if (!newValue && !this.menu.isOpen && this.alwaysOpen)
                this.openMenu();
            },
            flat: function flat() {
              this.initialize();
            },
            internalValue: function internalValue(newValue, oldValue) {
              var hasChanged = quickDiff(newValue, oldValue);
              if (hasChanged)
                this.$emit("update:modelValue", this.getValue(), this.getInstanceId());
            },
            matchKeys: function matchKeys() {
              this.initialize();
            },
            multiple: function multiple(newValue) {
              if (newValue)
                this.buildForestState();
            },
            options: {
              handler: function handler() {
                if (this.async)
                  return;
                this.initialize();
                this.rootOptionsStates.isLoaded = Array.isArray(this.options);
              },
              deep: true,
              immediate: true
            },
            "trigger.searchQuery": function triggerSearchQuery() {
              if (this.async) {
                this.handleRemoteSearch();
              } else {
                this.handleLocalSearch();
              }
              this.$emit("search-change", this.trigger.searchQuery, this.getInstanceId());
            },
            value: function value() {
              var nodeIdsFromValue = this.extractCheckedNodeIdsFromValue();
              var hasChanged = quickDiff(nodeIdsFromValue, this.internalValue);
              if (hasChanged)
                this.fixSelectedNodeIds(nodeIdsFromValue);
            }
          },
          methods: {
            verifyProps: function verifyProps() {
              var _this3 = this;
              warning(function() {
                return _this3.async ? _this3.searchable : true;
              }, function() {
                return 'For async search mode, the value of "searchable" prop must be true.';
              });
              if (this.options == null && !this.loadOptions) {
                warning(function() {
                  return false;
                }, function() {
                  return 'Are you meant to dynamically load options? You need to use "loadOptions" prop.';
                });
              }
              if (this.flat) {
                warning(function() {
                  return _this3.multiple;
                }, function() {
                  return 'You are using flat mode. But you forgot to add "multiple=true"?';
                });
              }
              if (!this.flat) {
                var propNames = ["autoSelectAncestors", "autoSelectDescendants", "autoDeselectAncestors", "autoDeselectDescendants"];
                propNames.forEach(function(propName) {
                  warning(function() {
                    return !_this3[propName];
                  }, function() {
                    return '"'.concat(propName, '" only applies to flat mode.');
                  });
                });
              }
            },
            resetFlags: function resetFlags() {
              this._blurOnSelect = false;
            },
            initialize: function initialize() {
              var options = this.async ? this.getRemoteSearchEntry().options : this.options;
              if (Array.isArray(options)) {
                var prevNodeMap = this.forest.nodeMap;
                this.forest.nodeMap = createMap();
                this.keepDataOfSelectedNodes(prevNodeMap);
                this.forest.normalizedOptions = this.normalize(NO_PARENT_NODE, options, prevNodeMap);
                this.fixSelectedNodeIds(this.internalValue);
              } else {
                this.forest.normalizedOptions = [];
              }
            },
            getInstanceId: function getInstanceId() {
              return this.instanceId == null ? this.id : this.instanceId;
            },
            getValue: function getValue() {
              var _this4 = this;
              if (this.valueFormat === "id") {
                return this.multiple ? this.internalValue.slice() : this.internalValue[0];
              }
              var rawNodes = this.internalValue.map(function(id) {
                return _this4.getNode(id).raw;
              });
              return this.multiple ? rawNodes : rawNodes[0];
            },
            getNode: function getNode(nodeId) {
              warning(function() {
                return nodeId != null;
              }, function() {
                return "Invalid node id: ".concat(nodeId);
              });
              if (nodeId == null)
                return null;
              return nodeId in this.forest.nodeMap ? this.forest.nodeMap[nodeId] : this.createFallbackNode(nodeId);
            },
            createFallbackNode: function createFallbackNode(id) {
              var raw = this.extractNodeFromValue(id);
              var label = this.enhancedNormalizer(raw).label || "".concat(id, " (unknown)");
              var fallbackNode = {
                id,
                label,
                ancestors: [],
                parentNode: NO_PARENT_NODE,
                isFallbackNode: true,
                isRootNode: true,
                isLeaf: true,
                isBranch: false,
                isDisabled: false,
                isNew: false,
                index: [-1],
                level: 0,
                raw
              };
              return this.forest.nodeMap[id] = fallbackNode;
            },
            extractCheckedNodeIdsFromValue: function extractCheckedNodeIdsFromValue() {
              var _this5 = this;
              if (this.modelValue == null)
                return [];
              if (this.valueFormat === "id") {
                return this.multiple ? this.modelValue.slice() : [this.modelValue];
              }
              return (this.multiple ? this.modelValue : [this.modelValue]).map(function(node) {
                return _this5.enhancedNormalizer(node);
              }).map(function(node) {
                return node.id;
              });
            },
            extractNodeFromValue: function extractNodeFromValue(id) {
              var _this6 = this;
              var defaultNode = {
                id
              };
              if (this.valueFormat === "id") {
                return defaultNode;
              }
              var valueArray = this.multiple ? Array.isArray(this.modelValue) ? this.modelValue : [] : this.modelValue ? [this.modelValue] : [];
              var matched = find(valueArray, function(node) {
                return node && _this6.enhancedNormalizer(node).id === id;
              });
              return matched || defaultNode;
            },
            fixSelectedNodeIds: function fixSelectedNodeIds(nodeIdListOfPrevValue) {
              var _this7 = this;
              var nextSelectedNodeIds = [];
              if (this.single || this.flat || this.disableBranchNodes || this.valueConsistsOf === ALL) {
                nextSelectedNodeIds = nodeIdListOfPrevValue;
              } else if (this.valueConsistsOf === BRANCH_PRIORITY) {
                nodeIdListOfPrevValue.forEach(function(nodeId2) {
                  nextSelectedNodeIds.push(nodeId2);
                  var node2 = _this7.getNode(nodeId2);
                  if (node2.isBranch)
                    _this7.traverseDescendantsBFS(node2, function(descendant) {
                      nextSelectedNodeIds.push(descendant.id);
                    });
                });
              } else if (this.valueConsistsOf === LEAF_PRIORITY) {
                var map = createMap();
                var queue = nodeIdListOfPrevValue.slice();
                while (queue.length) {
                  var nodeId = queue.shift();
                  var node = this.getNode(nodeId);
                  nextSelectedNodeIds.push(nodeId);
                  if (node.isRootNode)
                    continue;
                  if (!(node.parentNode.id in map))
                    map[node.parentNode.id] = node.parentNode.children.length;
                  if (--map[node.parentNode.id] === 0)
                    queue.push(node.parentNode.id);
                }
              } else if (this.valueConsistsOf === ALL_WITH_INDETERMINATE) {
                var _map = createMap();
                var _queue = nodeIdListOfPrevValue.filter(function(nodeId2) {
                  var node2 = _this7.getNode(nodeId2);
                  return node2.isLeaf || node2.children.length === 0;
                });
                while (_queue.length) {
                  var _nodeId = _queue.shift();
                  var _node = this.getNode(_nodeId);
                  nextSelectedNodeIds.push(_nodeId);
                  if (_node.isRootNode)
                    continue;
                  if (!(_node.parentNode.id in _map))
                    _map[_node.parentNode.id] = _node.parentNode.children.length;
                  if (--_map[_node.parentNode.id] === 0)
                    _queue.push(_node.parentNode.id);
                }
              }
              var hasChanged = quickDiff(this.forest.selectedNodeIds, nextSelectedNodeIds);
              if (hasChanged)
                this.forest.selectedNodeIds = nextSelectedNodeIds;
              this.buildForestState();
            },
            keepDataOfSelectedNodes: function keepDataOfSelectedNodes(prevNodeMap) {
              var _this8 = this;
              this.forest.selectedNodeIds.forEach(function(id) {
                if (!prevNodeMap[id])
                  return;
                var node = _objectSpread2(_objectSpread2({}, prevNodeMap[id]), {}, {
                  isFallbackNode: true
                });
                _this8.forest.nodeMap[id] = node;
              });
            },
            isSelected: function isSelected(node) {
              return this.forest.selectedNodeMap[node.id] === true;
            },
            traverseDescendantsBFS: function traverseDescendantsBFS(parentNode, callback) {
              if (!parentNode.isBranch)
                return;
              var queue = parentNode.children.slice();
              while (queue.length) {
                var currNode = queue[0];
                if (currNode.isBranch)
                  queue.push.apply(queue, _toConsumableArray(currNode.children));
                callback(currNode);
                queue.shift();
              }
            },
            traverseDescendantsDFS: function traverseDescendantsDFS(parentNode, callback) {
              var _this9 = this;
              if (!parentNode.isBranch)
                return;
              parentNode.children.forEach(function(child) {
                _this9.traverseDescendantsDFS(child, callback);
                callback(child);
              });
            },
            traverseAllNodesDFS: function traverseAllNodesDFS(callback) {
              var _this10 = this;
              this.forest.normalizedOptions.forEach(function(rootNode) {
                _this10.traverseDescendantsDFS(rootNode, callback);
                callback(rootNode);
              });
            },
            traverseAllNodesByIndex: function traverseAllNodesByIndex(callback) {
              var walk2 = function walk3(parentNode) {
                parentNode.children.forEach(function(child) {
                  if (callback(child) !== false && child.isBranch) {
                    walk3(child);
                  }
                });
              };
              walk2({
                children: this.forest.normalizedOptions
              });
            },
            toggleClickOutsideEvent: function toggleClickOutsideEvent(enabled) {
              if (enabled) {
                document.addEventListener("mousedown", this.handleClickOutside, false);
              } else {
                document.removeEventListener("mousedown", this.handleClickOutside, false);
              }
            },
            getValueContainer: function getValueContainer() {
              return this.$refs.control.$refs["value-container"];
            },
            getInput: function getInput() {
              return this.getValueContainer().$refs.input;
            },
            focusInput: function focusInput() {
              this.getInput().focus();
            },
            blurInput: function blurInput() {
              this.getInput().blur();
            },
            handleMouseDown: onLeftClick(function handleMouseDown(evt) {
              evt.preventDefault();
              evt.stopPropagation();
              if (this.disabled)
                return;
              var isClickedOnValueContainer = this.getValueContainer().$el.contains(evt.target);
              if (isClickedOnValueContainer && !this.menu.isOpen && (this.openOnClick || this.trigger.isFocused)) {
                this.openMenu();
              }
              if (this._blurOnSelect) {
                this.blurInput();
              } else {
                this.focusInput();
              }
              this.resetFlags();
            }),
            handleClickOutside: function handleClickOutside(evt) {
              if (this.$refs.wrapper && !this.$refs.wrapper.contains(evt.target)) {
                this.blurInput();
                this.closeMenu();
              }
            },
            handleLocalSearch: function handleLocalSearch() {
              var _this11 = this;
              var searchQuery = this.trigger.searchQuery;
              var done = function done2() {
                return _this11.resetHighlightedOptionWhenNecessary(true);
              };
              if (!searchQuery) {
                this.localSearch.active = false;
                return done();
              }
              this.localSearch.active = true;
              this.localSearch.noResults = true;
              this.traverseAllNodesDFS(function(node) {
                if (node.isBranch) {
                  var _this11$localSearch$c;
                  node.isExpandedOnSearch = false;
                  node.showAllChildrenOnSearch = false;
                  node.isMatched = false;
                  node.hasMatchedDescendants = false;
                  _this11.localSearch.countMap[node.id] = (_this11$localSearch$c = {}, _defineProperty(_this11$localSearch$c, ALL_CHILDREN, 0), _defineProperty(_this11$localSearch$c, ALL_DESCENDANTS, 0), _defineProperty(_this11$localSearch$c, LEAF_CHILDREN, 0), _defineProperty(_this11$localSearch$c, LEAF_DESCENDANTS, 0), _this11$localSearch$c);
                }
              });
              var lowerCasedSearchQuery = searchQuery.trim().toLocaleLowerCase();
              var splitSearchQuery = lowerCasedSearchQuery.replace(/\s+/g, " ").split(" ");
              this.traverseAllNodesDFS(function(node) {
                if (_this11.searchNested && splitSearchQuery.length > 1) {
                  node.isMatched = splitSearchQuery.every(function(filterValue) {
                    return match(false, filterValue, node.nestedSearchLabel);
                  });
                } else {
                  node.isMatched = _this11.matchKeys.some(function(matchKey) {
                    return match(!_this11.disableFuzzyMatching, lowerCasedSearchQuery, node.lowerCased[matchKey]);
                  });
                }
                if (node.isMatched) {
                  _this11.localSearch.noResults = false;
                  node.ancestors.forEach(function(ancestor) {
                    return _this11.localSearch.countMap[ancestor.id][ALL_DESCENDANTS]++;
                  });
                  if (node.isLeaf)
                    node.ancestors.forEach(function(ancestor) {
                      return _this11.localSearch.countMap[ancestor.id][LEAF_DESCENDANTS]++;
                    });
                  if (node.parentNode !== NO_PARENT_NODE) {
                    _this11.localSearch.countMap[node.parentNode.id][ALL_CHILDREN] += 1;
                    if (node.isLeaf)
                      _this11.localSearch.countMap[node.parentNode.id][LEAF_CHILDREN] += 1;
                  }
                }
                if ((node.isMatched || node.isBranch && node.isExpandedOnSearch) && node.parentNode !== NO_PARENT_NODE) {
                  node.parentNode.isExpandedOnSearch = true;
                  node.parentNode.hasMatchedDescendants = true;
                }
              });
              done();
            },
            handleRemoteSearch: function handleRemoteSearch() {
              var _this12 = this;
              var searchQuery = this.trigger.searchQuery;
              var entry = this.getRemoteSearchEntry();
              var done = function done2() {
                _this12.initialize();
                _this12.resetHighlightedOptionWhenNecessary(true);
              };
              if ((searchQuery === "" || this.cacheOptions) && entry.isLoaded) {
                return done();
              }
              this.callLoadOptionsProp({
                action: ASYNC_SEARCH,
                args: {
                  searchQuery
                },
                isPending: function isPending() {
                  return entry.isLoading;
                },
                start: function start() {
                  entry.isLoading = true;
                  entry.isLoaded = false;
                  entry.loadingError = "";
                },
                succeed: function succeed(options) {
                  entry.isLoaded = true;
                  entry.options = options;
                  if (_this12.trigger.searchQuery === searchQuery)
                    done();
                },
                fail: function fail(err) {
                  entry.loadingError = getErrorMessage(err);
                },
                end: function end() {
                  entry.isLoading = false;
                }
              });
            },
            getRemoteSearchEntry: function getRemoteSearchEntry() {
              var _this13 = this;
              var searchQuery = this.trigger.searchQuery;
              var entry = this.remoteSearch[searchQuery] || _objectSpread2(_objectSpread2({}, createAsyncOptionsStates()), {}, {
                options: []
              });
              this.$watch(function() {
                return entry.options;
              }, function() {
                if (_this13.trigger.searchQuery === searchQuery)
                  _this13.initialize();
              }, {
                deep: true
              });
              if (searchQuery === "") {
                if (Array.isArray(this.defaultOptions)) {
                  entry.options = this.defaultOptions;
                  entry.isLoaded = true;
                  return entry;
                } else if (this.defaultOptions !== true) {
                  entry.isLoaded = true;
                  return entry;
                }
              }
              if (!this.remoteSearch[searchQuery]) {
                this.remoteSearch[searchQuery] = entry;
              }
              return entry;
            },
            shouldExpand: function shouldExpand(node) {
              return this.localSearch.active ? node.isExpandedOnSearch : node.isExpanded;
            },
            shouldOptionBeIncludedInSearchResult: function shouldOptionBeIncludedInSearchResult(node) {
              if (node.isMatched)
                return true;
              if (node.isBranch && node.hasMatchedDescendants && !this.flattenSearchResults)
                return true;
              if (!node.isRootNode && node.parentNode.showAllChildrenOnSearch)
                return true;
              return false;
            },
            shouldShowOptionInMenu: function shouldShowOptionInMenu(node) {
              if (this.localSearch.active && !this.shouldOptionBeIncludedInSearchResult(node)) {
                return false;
              }
              return true;
            },
            getControl: function getControl() {
              return this.$refs.control.$el;
            },
            getMenu: function getMenu() {
              var ref = this.appendToBody ? this.$refs.portal.portalTarget : this;
              var $menu = ref.$refs.menu.$refs.menu;
              return $menu && $menu.nodeName !== "#comment" ? $menu : null;
            },
            setCurrentHighlightedOption: function setCurrentHighlightedOption(node) {
              var _this14 = this;
              var scroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var prev = this.menu.current;
              if (prev != null && prev in this.forest.nodeMap) {
                this.forest.nodeMap[prev].isHighlighted = false;
              }
              this.menu.current = node.id;
              node.isHighlighted = true;
              if (this.menu.isOpen && scroll) {
                var scrollToOption = function scrollToOption2() {
                  var $menu = _this14.getMenu();
                  var $option = $menu.querySelector('.vue-treeselect__option[data-id="'.concat(node.id, '"]'));
                  if ($option)
                    scrollIntoView($menu, $option);
                };
                if (this.getMenu()) {
                  scrollToOption();
                } else {
                  this.$nextTick(scrollToOption);
                }
              }
            },
            resetHighlightedOptionWhenNecessary: function resetHighlightedOptionWhenNecessary() {
              var forceReset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
              var current = this.menu.current;
              if (forceReset || current == null || !(current in this.forest.nodeMap) || !this.shouldShowOptionInMenu(this.getNode(current))) {
                this.highlightFirstOption();
              }
            },
            highlightFirstOption: function highlightFirstOption() {
              if (!this.hasVisibleOptions)
                return;
              var first = this.visibleOptionIds[0];
              this.setCurrentHighlightedOption(this.getNode(first));
            },
            highlightPrevOption: function highlightPrevOption() {
              if (!this.hasVisibleOptions)
                return;
              var prev = this.visibleOptionIds.indexOf(this.menu.current) - 1;
              if (prev === -1)
                return this.highlightLastOption();
              this.setCurrentHighlightedOption(this.getNode(this.visibleOptionIds[prev]));
            },
            highlightNextOption: function highlightNextOption() {
              if (!this.hasVisibleOptions)
                return;
              var next = this.visibleOptionIds.indexOf(this.menu.current) + 1;
              if (next === this.visibleOptionIds.length)
                return this.highlightFirstOption();
              this.setCurrentHighlightedOption(this.getNode(this.visibleOptionIds[next]));
            },
            highlightLastOption: function highlightLastOption() {
              if (!this.hasVisibleOptions)
                return;
              var last2 = last_default()(this.visibleOptionIds);
              this.setCurrentHighlightedOption(this.getNode(last2));
            },
            resetSearchQuery: function resetSearchQuery() {
              this.trigger.searchQuery = "";
            },
            closeMenu: function closeMenu() {
              if (!this.menu.isOpen || !this.disabled && this.alwaysOpen)
                return;
              this.saveMenuScrollPosition();
              this.menu.isOpen = false;
              this.toggleClickOutsideEvent(false);
              this.resetSearchQuery();
              this.$emit("close", this.getValue(), this.getInstanceId());
            },
            openMenu: function openMenu() {
              if (this.disabled || this.menu.isOpen)
                return;
              this.menu.isOpen = true;
              this.$nextTick(this.resetHighlightedOptionWhenNecessary);
              this.$nextTick(this.restoreMenuScrollPosition);
              if (!this.options && !this.async)
                this.loadRootOptions();
              this.toggleClickOutsideEvent(true);
              this.$emit("open", this.getInstanceId());
            },
            toggleMenu: function toggleMenu() {
              if (this.menu.isOpen) {
                this.closeMenu();
              } else {
                this.openMenu();
              }
            },
            toggleExpanded: function toggleExpanded(node) {
              var nextState;
              if (this.localSearch.active) {
                nextState = node.isExpandedOnSearch = !node.isExpandedOnSearch;
                if (nextState)
                  node.showAllChildrenOnSearch = true;
              } else {
                nextState = node.isExpanded = !node.isExpanded;
              }
              if (nextState && !node.childrenStates.isLoaded) {
                this.loadChildrenOptions(node);
              }
            },
            buildForestState: function buildForestState() {
              var _this15 = this;
              var selectedNodeMap = createMap();
              this.forest.selectedNodeIds.forEach(function(selectedNodeId) {
                selectedNodeMap[selectedNodeId] = true;
              });
              this.forest.selectedNodeMap = selectedNodeMap;
              var checkedStateMap = createMap();
              if (this.multiple) {
                this.traverseAllNodesByIndex(function(node) {
                  checkedStateMap[node.id] = UNCHECKED;
                });
                this.selectedNodes.forEach(function(selectedNode) {
                  checkedStateMap[selectedNode.id] = CHECKED;
                  if (!_this15.flat && !_this15.disableBranchNodes) {
                    selectedNode.ancestors.forEach(function(ancestorNode) {
                      if (!_this15.isSelected(ancestorNode)) {
                        checkedStateMap[ancestorNode.id] = INDETERMINATE;
                      }
                    });
                  }
                });
              }
              this.forest.checkedStateMap = checkedStateMap;
            },
            enhancedNormalizer: function enhancedNormalizer(raw) {
              return _objectSpread2(_objectSpread2({}, raw), this.normalizer(raw, this.getInstanceId()));
            },
            normalize: function normalize(parentNode, nodes, prevNodeMap) {
              var _this16 = this;
              var normalizedOptions = nodes.map(function(node) {
                return [_this16.enhancedNormalizer(node), node];
              }).map(function(_ref, index) {
                var _ref2 = _slicedToArray(_ref, 2), node = _ref2[0], raw = _ref2[1];
                _this16.checkDuplication(node);
                _this16.verifyNodeShape(node);
                var id = node.id, label = node.label, children = node.children, isDefaultExpanded = node.isDefaultExpanded;
                var isRootNode = parentNode === NO_PARENT_NODE;
                var level = isRootNode ? 0 : parentNode.level + 1;
                var isBranch = Array.isArray(children) || children === null;
                var isLeaf = !isBranch;
                var isDisabled = !!node.isDisabled || !_this16.flat && !isRootNode && parentNode.isDisabled;
                var isNew = !!node.isNew;
                var lowerCased = _this16.matchKeys.reduce(function(prev2, key) {
                  return _objectSpread2(_objectSpread2({}, prev2), {}, _defineProperty({}, key, stringifyOptionPropValue(node[key]).toLocaleLowerCase()));
                }, {});
                var nestedSearchLabel = isRootNode ? lowerCased.label : parentNode.nestedSearchLabel + " " + lowerCased.label;
                _this16.forest.nodeMap[id] = createMap();
                var normalized = _this16.forest.nodeMap[id];
                normalized.id = id;
                normalized.label = label;
                normalized.level = level;
                normalized.ancestors = isRootNode ? [] : [parentNode].concat(parentNode.ancestors);
                normalized.index = (isRootNode ? [] : parentNode.index).concat(index);
                normalized.parentNode = parentNode;
                normalized.lowerCased = lowerCased;
                normalized.nestedSearchLabel = nestedSearchLabel;
                normalized.isDisabled = isDisabled;
                normalized.isNew = isNew;
                normalized.isMatched = false;
                normalized.isHighlighted = false;
                normalized.isBranch = isBranch;
                normalized.isLeaf = isLeaf;
                normalized.isRootNode = isRootNode;
                normalized.raw = raw;
                if (isBranch) {
                  var _normalized$count;
                  var isLoaded = Array.isArray(children);
                  normalized.childrenStates = _objectSpread2(_objectSpread2({}, createAsyncOptionsStates()), {}, {
                    isLoaded
                  });
                  normalized.isExpanded = typeof isDefaultExpanded === "boolean" ? isDefaultExpanded : level < _this16.defaultExpandLevel;
                  normalized.hasMatchedDescendants = false;
                  normalized.hasDisabledDescendants = false;
                  normalized.isExpandedOnSearch = false;
                  normalized.showAllChildrenOnSearch = false;
                  normalized.count = (_normalized$count = {}, _defineProperty(_normalized$count, ALL_CHILDREN, 0), _defineProperty(_normalized$count, ALL_DESCENDANTS, 0), _defineProperty(_normalized$count, LEAF_CHILDREN, 0), _defineProperty(_normalized$count, LEAF_DESCENDANTS, 0), _normalized$count);
                  normalized.children = isLoaded ? _this16.normalize(normalized, children, prevNodeMap) : [];
                  if (isDefaultExpanded === true)
                    normalized.ancestors.forEach(function(ancestor) {
                      ancestor.isExpanded = true;
                    });
                  if (!isLoaded && typeof _this16.loadOptions !== "function") {
                    warning(function() {
                      return false;
                    }, function() {
                      return 'Unloaded branch node detected. "loadOptions" prop is required to load its children.';
                    });
                  } else if (!isLoaded && normalized.isExpanded) {
                    _this16.loadChildrenOptions(normalized);
                  }
                }
                normalized.ancestors.forEach(function(ancestor) {
                  return ancestor.count[ALL_DESCENDANTS]++;
                });
                if (isLeaf)
                  normalized.ancestors.forEach(function(ancestor) {
                    return ancestor.count[LEAF_DESCENDANTS]++;
                  });
                if (!isRootNode) {
                  parentNode.count[ALL_CHILDREN] += 1;
                  if (isLeaf)
                    parentNode.count[LEAF_CHILDREN] += 1;
                  if (isDisabled)
                    parentNode.hasDisabledDescendants = true;
                }
                if (prevNodeMap && prevNodeMap[id]) {
                  var prev = prevNodeMap[id];
                  normalized.isMatched = prev.isMatched;
                  normalized.showAllChildrenOnSearch = prev.showAllChildrenOnSearch;
                  normalized.isHighlighted = prev.isHighlighted;
                  if (prev.isBranch && normalized.isBranch) {
                    normalized.isExpanded = prev.isExpanded;
                    normalized.isExpandedOnSearch = prev.isExpandedOnSearch;
                    if (prev.childrenStates.isLoaded && !normalized.childrenStates.isLoaded) {
                      normalized.isExpanded = false;
                    } else {
                      normalized.childrenStates = _objectSpread2({}, prev.childrenStates);
                    }
                  }
                }
                return normalized;
              });
              if (this.branchNodesFirst) {
                var branchNodes = normalizedOptions.filter(function(option) {
                  return option.isBranch;
                });
                var leafNodes = normalizedOptions.filter(function(option) {
                  return option.isLeaf;
                });
                normalizedOptions = branchNodes.concat(leafNodes);
              }
              return normalizedOptions;
            },
            loadRootOptions: function loadRootOptions() {
              var _this17 = this;
              this.callLoadOptionsProp({
                action: LOAD_ROOT_OPTIONS,
                isPending: function isPending() {
                  return _this17.rootOptionsStates.isLoading;
                },
                start: function start() {
                  _this17.rootOptionsStates.isLoading = true;
                  _this17.rootOptionsStates.loadingError = "";
                },
                succeed: function succeed() {
                  _this17.rootOptionsStates.isLoaded = true;
                  _this17.$nextTick(function() {
                    _this17.resetHighlightedOptionWhenNecessary(true);
                  });
                },
                fail: function fail(err) {
                  _this17.rootOptionsStates.loadingError = getErrorMessage(err);
                },
                end: function end() {
                  _this17.rootOptionsStates.isLoading = false;
                }
              });
            },
            loadChildrenOptions: function loadChildrenOptions(parentNode) {
              var _this18 = this;
              var id = parentNode.id, raw = parentNode.raw;
              this.callLoadOptionsProp({
                action: LOAD_CHILDREN_OPTIONS,
                args: {
                  parentNode: raw
                },
                isPending: function isPending() {
                  return _this18.getNode(id).childrenStates.isLoading;
                },
                start: function start() {
                  _this18.getNode(id).childrenStates.isLoading = true;
                  _this18.getNode(id).childrenStates.loadingError = "";
                },
                succeed: function succeed() {
                  _this18.getNode(id).childrenStates.isLoaded = true;
                },
                fail: function fail(err) {
                  _this18.getNode(id).childrenStates.loadingError = getErrorMessage(err);
                },
                end: function end() {
                  _this18.getNode(id).childrenStates.isLoading = false;
                }
              });
            },
            callLoadOptionsProp: function callLoadOptionsProp(_ref3) {
              var action = _ref3.action, args = _ref3.args, isPending = _ref3.isPending, start = _ref3.start, succeed = _ref3.succeed, fail = _ref3.fail, end = _ref3.end;
              if (!this.loadOptions || isPending()) {
                return;
              }
              start();
              var callback = once_default()(function(err, result2) {
                if (err) {
                  fail(err);
                } else {
                  succeed(result2);
                }
                end();
              });
              var result = this.loadOptions(_objectSpread2(_objectSpread2({
                id: this.getInstanceId(),
                instanceId: this.getInstanceId(),
                action
              }, args), {}, {
                callback
              }));
              if (is_promise_default()(result)) {
                result.then(function() {
                  callback();
                }, function(err) {
                  callback(err);
                }).catch(function(err) {
                  console.error(err);
                });
              }
            },
            checkDuplication: function checkDuplication(node) {
              var _this19 = this;
              warning(function() {
                return !(node.id in _this19.forest.nodeMap && !_this19.forest.nodeMap[node.id].isFallbackNode);
              }, function() {
                return "Detected duplicate presence of node id ".concat(JSON.stringify(node.id), ". ") + 'Their labels are "'.concat(_this19.forest.nodeMap[node.id].label, '" and "').concat(node.label, '" respectively.');
              });
            },
            verifyNodeShape: function verifyNodeShape(node) {
              warning(function() {
                return !(node.children === void 0 && node.isBranch === true);
              }, function() {
                return "Are you meant to declare an unloaded branch node? `isBranch: true` is no longer supported, please use `children: null` instead.";
              });
            },
            select: function select(node) {
              if (this.disabled || node.isDisabled) {
                return;
              }
              if (this.single) {
                this.clear();
              }
              var nextState = this.multiple && !this.flat ? this.forest.checkedStateMap[node.id] === UNCHECKED : !this.isSelected(node);
              if (nextState) {
                this._selectNode(node);
              } else {
                this._deselectNode(node);
              }
              this.buildForestState();
              if (nextState) {
                this.$emit("select", node.raw, this.getInstanceId());
              } else {
                this.$emit("deselect", node.raw, this.getInstanceId());
              }
              if (this.localSearch.active && nextState && (this.single || this.clearOnSelect)) {
                this.resetSearchQuery();
              }
              if (this.single && this.closeOnSelect) {
                this.closeMenu();
                if (this.searchable) {
                  this._blurOnSelect = true;
                }
              }
            },
            clear: function clear() {
              var _this20 = this;
              if (this.hasValue) {
                if (this.single || this.allowClearingDisabled) {
                  this.forest.selectedNodeIds = [];
                } else {
                  this.forest.selectedNodeIds = this.forest.selectedNodeIds.filter(function(nodeId) {
                    return _this20.getNode(nodeId).isDisabled;
                  });
                }
                this.buildForestState();
              }
            },
            _selectNode: function _selectNode(node) {
              var _this21 = this;
              if (this.single || this.disableBranchNodes) {
                return this.addValue(node);
              }
              if (this.flat) {
                this.addValue(node);
                if (this.autoSelectAncestors) {
                  node.ancestors.forEach(function(ancestor) {
                    if (!_this21.isSelected(ancestor) && !ancestor.isDisabled)
                      _this21.addValue(ancestor);
                  });
                } else if (this.autoSelectDescendants) {
                  this.traverseDescendantsBFS(node, function(descendant) {
                    if (!_this21.isSelected(descendant) && !descendant.isDisabled)
                      _this21.addValue(descendant);
                  });
                }
                return;
              }
              var isFullyChecked = node.isLeaf || !node.hasDisabledDescendants || this.allowSelectingDisabledDescendants;
              if (isFullyChecked) {
                this.addValue(node);
              }
              if (node.isBranch) {
                this.traverseDescendantsBFS(node, function(descendant) {
                  if (!descendant.isDisabled || _this21.allowSelectingDisabledDescendants) {
                    _this21.addValue(descendant);
                  }
                });
              }
              if (isFullyChecked) {
                var curr = node;
                while ((curr = curr.parentNode) !== NO_PARENT_NODE) {
                  if (curr.children.every(this.isSelected))
                    this.addValue(curr);
                  else
                    break;
                }
              }
            },
            _deselectNode: function _deselectNode(node) {
              var _this22 = this;
              if (this.disableBranchNodes) {
                return this.removeValue(node);
              }
              if (this.flat) {
                this.removeValue(node);
                if (this.autoDeselectAncestors) {
                  node.ancestors.forEach(function(ancestor) {
                    if (_this22.isSelected(ancestor) && !ancestor.isDisabled)
                      _this22.removeValue(ancestor);
                  });
                } else if (this.autoDeselectDescendants) {
                  this.traverseDescendantsBFS(node, function(descendant) {
                    if (_this22.isSelected(descendant) && !descendant.isDisabled)
                      _this22.removeValue(descendant);
                  });
                }
                return;
              }
              var hasUncheckedSomeDescendants = false;
              if (node.isBranch) {
                this.traverseDescendantsDFS(node, function(descendant) {
                  if (!descendant.isDisabled || _this22.allowSelectingDisabledDescendants) {
                    _this22.removeValue(descendant);
                    hasUncheckedSomeDescendants = true;
                  }
                });
              }
              if (node.isLeaf || hasUncheckedSomeDescendants || node.children.length === 0) {
                this.removeValue(node);
                var curr = node;
                while ((curr = curr.parentNode) !== NO_PARENT_NODE) {
                  if (this.isSelected(curr))
                    this.removeValue(curr);
                  else
                    break;
                }
              }
            },
            addValue: function addValue(node) {
              this.forest.selectedNodeIds.push(node.id);
              this.forest.selectedNodeMap[node.id] = true;
            },
            removeValue: function removeValue(node) {
              removeFromArray(this.forest.selectedNodeIds, node.id);
              delete this.forest.selectedNodeMap[node.id];
            },
            removeLastValue: function removeLastValue() {
              if (!this.hasValue)
                return;
              if (this.single)
                return this.clear();
              var lastValue = last_default()(this.internalValue);
              var lastSelectedNode = this.getNode(lastValue);
              this.select(lastSelectedNode);
            },
            saveMenuScrollPosition: function saveMenuScrollPosition() {
              var $menu = this.getMenu();
              if ($menu)
                this.menu.lastScrollPosition = $menu.scrollTop;
            },
            restoreMenuScrollPosition: function restoreMenuScrollPosition() {
              var $menu = this.getMenu();
              if ($menu)
                $menu.scrollTop = this.menu.lastScrollPosition;
            }
          },
          created: function created() {
            this.verifyProps();
            this.resetFlags();
          },
          mounted: function mounted() {
            if (this.autoFocus)
              this.focusInput();
            if (!this.options && !this.async && this.autoLoadRootOptions)
              this.loadRootOptions();
            if (this.alwaysOpen)
              this.openMenu();
            if (this.async && this.defaultOptions)
              this.handleRemoteSearch();
          },
          unmounted: function unmounted() {
            this.toggleClickOutsideEvent(false);
          }
        };
        var es_array_join = __webpack_require__("a15b");
        function stringifyValue(value) {
          if (typeof value === "string")
            return value;
          if (value != null && !isNaN_isNaN(value))
            return JSON.stringify(value);
          return "";
        }
        var HiddenFieldsvue_type_script_lang_js = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
          name: "vue-treeselect--hidden-fields",
          inject: ["instance"],
          functional: true,
          render: function render(context) {
            var h = arguments[0];
            var instance = context.instance;
            if (!instance.name || instance.disabled || !instance.hasValue)
              return null;
            var stringifiedValues = instance.internalValue.map(stringifyValue);
            if (instance.multiple && instance.joinValues)
              stringifiedValues = [stringifiedValues.join(instance.delimiter)];
            return stringifiedValues.map(function(stringifiedValue, i) {
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("input", {
                "type": "hidden",
                "name": instance.name,
                "value": stringifiedValue,
                "key": "hidden-field-" + i
              }, null);
            });
          }
        });
        var HiddenFields = HiddenFieldsvue_type_script_lang_js;
        var es_object_to_string = __webpack_require__("d3b7");
        var es_regexp_to_string = __webpack_require__("25f0");
        var debounce = __webpack_require__("b047");
        var debounce_default = __webpack_require__.n(debounce);
        var es_object_get_prototype_of = __webpack_require__("3410");
        var es_object_keys = __webpack_require__("b64b");
        function _typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof(obj);
        }
        function isPlainObject(value) {
          if (value == null || _typeof(value) !== "object")
            return false;
          return Object.getPrototypeOf(value) === Object.prototype;
        }
        function copy(obj, key, value) {
          if (isPlainObject(value)) {
            obj[key] || (obj[key] = {});
            deepExtend(obj[key], value);
          } else {
            obj[key] = value;
          }
        }
        function deepExtend(target, source) {
          if (isPlainObject(source)) {
            var keys = Object.keys(source);
            for (var i = 0, len = keys.length; i < len; i++) {
              copy(target, keys[i], source[keys[i]]);
            }
          }
          return target;
        }
        function _isSlot(s) {
          return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(s);
        }
        var keysThatRequireMenuBeingOpen = [KEY_CODES.ENTER, KEY_CODES.END, KEY_CODES.HOME, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN];
        var Inputvue_type_script_lang_js = {
          name: "vue-treeselect--input",
          inject: ["instance"],
          data: function data() {
            return {
              inputWidth: MIN_INPUT_WIDTH,
              value: ""
            };
          },
          computed: {
            needAutoSize: function needAutoSize() {
              var instance = this.instance;
              return instance.searchable && !instance.disabled && instance.multiple;
            },
            inputStyle: function inputStyle() {
              return {
                width: this.needAutoSize ? "".concat(this.inputWidth, "px") : null
              };
            }
          },
          watch: {
            "instance.trigger.searchQuery": function instanceTriggerSearchQuery(newValue) {
              this.value = newValue;
            },
            value: function value() {
              if (this.needAutoSize)
                this.$nextTick(this.updateInputWidth);
            }
          },
          created: function created() {
            this.debouncedCallback = debounce_default()(this.updateSearchQuery, INPUT_DEBOUNCE_DELAY, {
              leading: true,
              trailing: true
            });
          },
          methods: {
            clear: function clear() {
              this.onInput({
                target: {
                  value: ""
                }
              });
            },
            focus: function focus() {
              var instance = this.instance;
              if (!instance.disabled) {
                this.$refs.input && this.$refs.input.focus();
              }
            },
            blur: function blur() {
              this.$refs.input && this.$refs.input.blur();
            },
            onFocus: function onFocus() {
              var instance = this.instance;
              instance.trigger.isFocused = true;
              if (instance.openOnFocus)
                instance.openMenu();
            },
            onBlur: function onBlur() {
              var instance = this.instance;
              var menu = instance.getMenu();
              if (menu && document.activeElement === menu) {
                return this.focus();
              }
              instance.trigger.isFocused = false;
              instance.closeMenu();
            },
            onInput: function onInput(evt) {
              var value = evt.target.value;
              this.value = value;
              if (value) {
                this.debouncedCallback();
              } else {
                this.debouncedCallback.cancel();
                this.updateSearchQuery();
              }
            },
            onKeyDown: function onKeyDown(evt) {
              var instance = this.instance;
              var key = "which" in evt ? evt.which : evt.keyCode;
              if (evt.ctrlKey || evt.shiftKey || evt.altKey || evt.metaKey)
                return;
              if (!instance.menu.isOpen && includes(keysThatRequireMenuBeingOpen, key)) {
                evt.preventDefault();
                return instance.openMenu();
              }
              switch (key) {
                case KEY_CODES.BACKSPACE: {
                  if (instance.backspaceRemoves && !this.value.length) {
                    instance.removeLastValue();
                  }
                  break;
                }
                case KEY_CODES.ENTER: {
                  evt.preventDefault();
                  if (instance.menu.current === null)
                    return;
                  var current = instance.getNode(instance.menu.current);
                  if (current.isBranch && instance.disableBranchNodes)
                    return;
                  instance.select(current);
                  break;
                }
                case KEY_CODES.ESCAPE: {
                  if (this.value.length) {
                    this.clear();
                  } else if (instance.menu.isOpen) {
                    instance.closeMenu();
                  }
                  break;
                }
                case KEY_CODES.END: {
                  evt.preventDefault();
                  instance.highlightLastOption();
                  break;
                }
                case KEY_CODES.HOME: {
                  evt.preventDefault();
                  instance.highlightFirstOption();
                  break;
                }
                case KEY_CODES.ARROW_LEFT: {
                  var _current = instance.getNode(instance.menu.current);
                  if (_current.isBranch && instance.shouldExpand(_current)) {
                    evt.preventDefault();
                    instance.toggleExpanded(_current);
                  } else if (!_current.isRootNode && (_current.isLeaf || _current.isBranch && !instance.shouldExpand(_current))) {
                    evt.preventDefault();
                    instance.setCurrentHighlightedOption(_current.parentNode);
                  }
                  break;
                }
                case KEY_CODES.ARROW_UP: {
                  evt.preventDefault();
                  instance.highlightPrevOption();
                  break;
                }
                case KEY_CODES.ARROW_RIGHT: {
                  var _current2 = instance.getNode(instance.menu.current);
                  if (_current2.isBranch && !instance.shouldExpand(_current2)) {
                    evt.preventDefault();
                    instance.toggleExpanded(_current2);
                  }
                  break;
                }
                case KEY_CODES.ARROW_DOWN: {
                  evt.preventDefault();
                  instance.highlightNextOption();
                  break;
                }
                case KEY_CODES.DELETE: {
                  if (instance.deleteRemoves && !this.value.length) {
                    instance.removeLastValue();
                  }
                  break;
                }
                default: {
                  instance.openMenu();
                }
              }
            },
            onMouseDown: function onMouseDown(evt) {
              if (this.value.length) {
                evt.stopPropagation();
              }
            },
            renderInputContainer: function renderInputContainer() {
              var h = this.$createElement;
              var instance = this.instance;
              var props = {};
              var children = [];
              if (instance.searchable && !instance.disabled) {
                children.push(this.renderInput());
                if (this.needAutoSize)
                  children.push(this.renderSizer());
              }
              if (!instance.searchable) {
                deepExtend(props, {
                  on: {
                    focus: this.onFocus,
                    blur: this.onBlur,
                    keydown: this.onKeyDown
                  },
                  ref: "input"
                });
              }
              if (!instance.searchable && !instance.disabled) {
                deepExtend(props, {
                  attrs: {
                    tabIndex: instance.tabIndex
                  }
                });
              }
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", Object(external_commonjs_vue_commonjs2_vue_root_Vue_["mergeProps"])({
                "class": "vue-treeselect__input-container"
              }, props), _isSlot(children) ? children : {
                default: function _default() {
                  return [children];
                }
              });
            },
            renderInput: function renderInput() {
              var h = this.$createElement;
              var instance = this.instance;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("input", {
                "ref": "input",
                "class": "vue-treeselect__input",
                "type": "text",
                "autocomplete": "off",
                "tabIndex": instance.tabIndex,
                "required": instance.required && !instance.hasValue,
                "value": this.value,
                "style": this.inputStyle,
                "onFocus": this.onFocus,
                "onInput": this.onInput,
                "onBlur": this.onBlur,
                "onKeydown": this.onKeyDown,
                "onMousedown": this.onMouseDown
              }, null);
            },
            renderSizer: function renderSizer() {
              var h = this.$createElement;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "ref": "sizer",
                "class": "vue-treeselect__sizer"
              }, [this.value]);
            },
            updateInputWidth: function updateInputWidth() {
              this.inputWidth = Math.max(MIN_INPUT_WIDTH, this.$refs.sizer.scrollWidth + 15);
            },
            updateSearchQuery: function updateSearchQuery() {
              var instance = this.instance;
              instance.trigger.searchQuery = this.value;
            }
          },
          render: function render() {
            return this.renderInputContainer();
          }
        };
        var Input = Inputvue_type_script_lang_js;
        var Placeholdervue_type_script_lang_js = {
          name: "vue-treeselect--placeholder",
          inject: ["instance"],
          render: function render() {
            var h = arguments[0];
            var instance = this.instance;
            var placeholderClass = {
              "vue-treeselect__placeholder": true,
              "vue-treeselect-helper-zoom-effect-off": true,
              "vue-treeselect-helper-hide": instance.hasValue || instance.trigger.searchQuery
            };
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": placeholderClass
            }, [instance.placeholder]);
          }
        };
        var Placeholder = Placeholdervue_type_script_lang_js;
        var SingleValuevue_type_script_lang_js = {
          name: "vue-treeselect--single-value",
          inject: ["instance"],
          methods: {
            renderSingleValueLabel: function renderSingleValueLabel() {
              var instance = this.instance;
              var node = instance.selectedNodes[0];
              var customValueLabelRenderer = instance.$slots["value-label"];
              return customValueLabelRenderer ? customValueLabelRenderer({
                node
              }) : node.label;
            }
          },
          render: function render() {
            var h = arguments[0];
            var instance = this.instance, renderValueContainer = this.$parent.renderValueContainer;
            var shouldShowValue = instance.hasValue && !instance.trigger.searchQuery;
            return renderValueContainer([shouldShowValue && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": "vue-treeselect__single-value"
            }, [this.renderSingleValueLabel()]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Placeholder, null, null), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Input, {
              "ref": "input"
            }, null)]);
          }
        };
        var SingleValue = SingleValuevue_type_script_lang_js;
        var _hoisted_1 = {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 348.333 348.333"
        };
        var _hoisted_2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("path", {
          d: "M336.559 68.611L231.016 174.165l105.543 105.549c15.699 15.705 15.699 41.145 0 56.85-7.844 7.844-18.128 11.769-28.407 11.769-10.296 0-20.581-3.919-28.419-11.769L174.167 231.003 68.609 336.563c-7.843 7.844-18.128 11.769-28.416 11.769-10.285 0-20.563-3.919-28.413-11.769-15.699-15.698-15.699-41.139 0-56.85l105.54-105.549L11.774 68.611c-15.699-15.699-15.699-41.145 0-56.844 15.696-15.687 41.127-15.687 56.829 0l105.563 105.554L279.721 11.767c15.705-15.687 41.139-15.687 56.832 0 15.705 15.699 15.705 41.145.006 56.844z"
        }, null, -1);
        function Deletevue_type_template_id_12b4a02e_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("svg", _hoisted_1, [_hoisted_2]);
        }
        var Deletevue_type_script_lang_js = {
          name: "vue-treeselect--x"
        };
        Deletevue_type_script_lang_js.render = Deletevue_type_template_id_12b4a02e_render;
        var Delete = Deletevue_type_script_lang_js;
        function MultiValueItemvue_type_script_lang_js_isSlot(s) {
          return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(s);
        }
        var MultiValueItemvue_type_script_lang_js = {
          name: "vue-treeselect--multi-value-item",
          inject: ["instance"],
          props: {
            node: {
              type: Object,
              required: true
            }
          },
          methods: {
            handleMouseDown: onLeftClick(function handleMouseDown() {
              var instance = this.instance, node = this.node;
              instance.select(node);
            })
          },
          render: function render() {
            var h = arguments[0];
            var instance = this.instance, node = this.node;
            var itemClass = {
              "vue-treeselect__multi-value-item": true,
              "vue-treeselect__multi-value-item-disabled": node.isDisabled,
              "vue-treeselect__multi-value-item-new": node.isNew
            };
            var customValueLabelRenderer = instance.$slots["value-label"];
            var labelRenderer = customValueLabelRenderer ? customValueLabelRenderer({
              node
            }) : node.label;
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": "vue-treeselect__multi-value-item-container"
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": itemClass,
              "onMousedown": this.handleMouseDown
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
              "class": "vue-treeselect__multi-value-label"
            }, MultiValueItemvue_type_script_lang_js_isSlot(labelRenderer) ? labelRenderer : {
              default: function _default() {
                return [labelRenderer];
              }
            }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
              "class": "vue-treeselect__icon vue-treeselect__value-remove"
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Delete, null, null)])])]);
          }
        };
        var MultiValueItem = MultiValueItemvue_type_script_lang_js;
        var MultiValuevue_type_script_lang_js = {
          name: "vue-treeselect--multi-value",
          inject: ["instance"],
          methods: {
            renderMultiValueItems: function renderMultiValueItems() {
              var h = this.$createElement;
              var instance = this.instance;
              return instance.internalValue.slice(0, instance.limit).map(instance.getNode).map(function(node) {
                return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(MultiValueItem, {
                  "key": "multi-value-item-".concat(node.id),
                  "node": node
                }, null);
              });
            },
            renderExceedLimitTip: function renderExceedLimitTip() {
              var h = this.$createElement;
              var instance = this.instance;
              var count = instance.internalValue.length - instance.limit;
              if (count <= 0)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__limit-tip vue-treeselect-helper-zoom-effect-off",
                "key": "exceed-limit-tip"
              }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
                "class": "vue-treeselect__limit-tip-text"
              }, [instance.limitText(count)])]);
            }
          },
          render: function render() {
            var _this = this;
            var h = arguments[0];
            var renderValueContainer = this.$parent.renderValueContainer;
            return renderValueContainer(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("transition-group"), {
              "class": "vue-treeselect__multi-value",
              "tag": "div",
              "name": "vue-treeselect__multi-value-item--transition",
              "appear": true
            }, {
              default: function _default() {
                return [_this.renderMultiValueItems(), _this.renderExceedLimitTip(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Placeholder, {
                  "key": "placeholder"
                }, null), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Input, {
                  "ref": "input",
                  "key": "input"
                }, null)];
              }
            }));
          }
        };
        var MultiValue = MultiValuevue_type_script_lang_js;
        var Arrowvue_type_template_id_5d5151cb_hoisted_1 = {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 292.362 292.362"
        };
        var Arrowvue_type_template_id_5d5151cb_hoisted_2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("path", {
          d: "M286.935 69.377c-3.614-3.617-7.898-5.424-12.848-5.424H18.274c-4.952 0-9.233 1.807-12.85 5.424C1.807 72.998 0 77.279 0 82.228c0 4.948 1.807 9.229 5.424 12.847l127.907 127.907c3.621 3.617 7.902 5.428 12.85 5.428s9.233-1.811 12.847-5.428L286.935 95.074c3.613-3.617 5.427-7.898 5.427-12.847 0-4.948-1.814-9.229-5.427-12.85z"
        }, null, -1);
        function Arrowvue_type_template_id_5d5151cb_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("svg", Arrowvue_type_template_id_5d5151cb_hoisted_1, [Arrowvue_type_template_id_5d5151cb_hoisted_2]);
        }
        var Arrowvue_type_script_lang_js = {
          name: "vue-treeselect--arrow"
        };
        Arrowvue_type_script_lang_js.render = Arrowvue_type_template_id_5d5151cb_render;
        var Arrow = Arrowvue_type_script_lang_js;
        function Controlvue_type_script_lang_js_isSlot(s) {
          return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(s);
        }
        var Controlvue_type_script_lang_js = {
          name: "vue-treeselect--control",
          inject: ["instance"],
          computed: {
            shouldShowX: function shouldShowX() {
              var instance = this.instance;
              return instance.clearable && !instance.disabled && instance.hasValue && (this.hasUndisabledValue || instance.allowClearingDisabled);
            },
            shouldShowArrow: function shouldShowArrow() {
              var instance = this.instance;
              if (!instance.alwaysOpen)
                return true;
              return !instance.menu.isOpen;
            },
            hasUndisabledValue: function hasUndisabledValue() {
              var instance = this.instance;
              return instance.hasValue && instance.internalValue.some(function(id) {
                return !instance.getNode(id).isDisabled;
              });
            }
          },
          methods: {
            renderX: function renderX() {
              var h = this.$createElement;
              var instance = this.instance;
              var title = instance.multiple ? instance.clearAllText : instance.clearValueText;
              if (!this.shouldShowX)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__x-container",
                "title": title,
                "onMousedown": this.handleMouseDownOnX
              }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Delete, {
                "class": "vue-treeselect__x"
              }, null)]);
            },
            renderArrow: function renderArrow() {
              var h = this.$createElement;
              var instance = this.instance;
              var arrowClass = {
                "vue-treeselect__control-arrow": true,
                "vue-treeselect__control-arrow--rotated": instance.menu.isOpen
              };
              if (!this.shouldShowArrow)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__control-arrow-container",
                "onMousedown": this.handleMouseDownOnArrow
              }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Arrow, {
                "class": arrowClass
              }, null)]);
            },
            handleMouseDownOnX: onLeftClick(function handleMouseDownOnX(evt) {
              evt.stopPropagation();
              evt.preventDefault();
              var instance = this.instance;
              var result = instance.beforeClearAll();
              var handler = function handler2(shouldClear) {
                if (shouldClear)
                  instance.clear();
              };
              if (is_promise_default()(result)) {
                result.then(handler);
              } else {
                setTimeout(function() {
                  return handler(result);
                }, 0);
              }
            }),
            handleMouseDownOnArrow: onLeftClick(function handleMouseDownOnArrow(evt) {
              evt.preventDefault();
              evt.stopPropagation();
              var instance = this.instance;
              instance.focusInput();
              instance.toggleMenu();
            }),
            renderValueContainer: function renderValueContainer(children) {
              var h = this.$createElement;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__value-container"
              }, Controlvue_type_script_lang_js_isSlot(children) ? children : {
                default: function _default() {
                  return [children];
                }
              });
            }
          },
          render: function render() {
            var h = arguments[0];
            var instance = this.instance;
            var ValueContainer = instance.single ? SingleValue : MultiValue;
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": "vue-treeselect__control",
              "onMousedown": instance.handleMouseDown
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(ValueContainer, {
              "ref": "value-container"
            }, null), this.renderX(), this.renderArrow()]);
          }
        };
        var Control = Controlvue_type_script_lang_js;
        var index_es_index = function(element, listener) {
          var expand = document.createElement("_");
          var shrink = expand.appendChild(document.createElement("_"));
          var expandChild = expand.appendChild(document.createElement("_"));
          var shrinkChild = shrink.appendChild(document.createElement("_"));
          var lastWidth = void 0, lastHeight = void 0;
          shrink.style.cssText = expand.style.cssText = "height:100%;left:0;opacity:0;overflow:hidden;pointer-events:none;position:absolute;top:0;transition:0s;width:100%;z-index:-1";
          shrinkChild.style.cssText = expandChild.style.cssText = "display:block;height:100%;transition:0s;width:100%";
          shrinkChild.style.width = shrinkChild.style.height = "200%";
          element.appendChild(expand);
          test2();
          return stop2;
          function test2() {
            unbind();
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            if (width !== lastWidth || height !== lastHeight) {
              lastWidth = width;
              lastHeight = height;
              expandChild.style.width = width * 2 + "px";
              expandChild.style.height = height * 2 + "px";
              expand.scrollLeft = expand.scrollWidth;
              expand.scrollTop = expand.scrollHeight;
              shrink.scrollLeft = shrink.scrollWidth;
              shrink.scrollTop = shrink.scrollHeight;
              listener({ width, height });
            }
            shrink.addEventListener("scroll", test2);
            expand.addEventListener("scroll", test2);
          }
          function unbind() {
            shrink.removeEventListener("scroll", test2);
            expand.removeEventListener("scroll", test2);
          }
          function stop2() {
            unbind();
            element.removeChild(expand);
          }
        };
        var index_es = index_es_index;
        var intervalId;
        var registered = [];
        var INTERVAL_DURATION = 100;
        function run() {
          intervalId = setInterval(function() {
            registered.forEach(test);
          }, INTERVAL_DURATION);
        }
        function stop() {
          clearInterval(intervalId);
          intervalId = null;
        }
        function test(item) {
          var $el = item.$el, listener = item.listener, lastWidth = item.lastWidth, lastHeight = item.lastHeight;
          var width = $el.offsetWidth;
          var height = $el.offsetHeight;
          if (lastWidth !== width || lastHeight !== height) {
            item.lastWidth = width;
            item.lastHeight = height;
            listener({
              width,
              height
            });
          }
        }
        function watchSizeForIE9($el, listener) {
          var item = {
            $el,
            listener,
            lastWidth: null,
            lastHeight: null
          };
          var unwatch = function unwatch2() {
            removeFromArray(registered, item);
            if (!registered.length)
              stop();
          };
          registered.push(item);
          test(item);
          run();
          return unwatch;
        }
        function watchSize($el, listener) {
          var isIE9 = document.documentMode === 9;
          var locked = true;
          var wrappedListener = function wrappedListener2() {
            return locked || listener.apply(void 0, arguments);
          };
          var implementation = isIE9 ? watchSizeForIE9 : index_es;
          var removeSizeWatcher = implementation($el, wrappedListener);
          locked = false;
          return removeSizeWatcher;
        }
        function findScrollParents($el) {
          var $scrollParents = [];
          var $parent = $el.parentNode;
          while ($parent && $parent.nodeName !== "BODY" && $parent.nodeType === document.ELEMENT_NODE) {
            if (isScrollElment($parent))
              $scrollParents.push($parent);
            $parent = $parent.parentNode;
          }
          $scrollParents.push(window);
          return $scrollParents;
        }
        function isScrollElment($el) {
          var _getComputedStyle = getComputedStyle($el), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
          return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX);
        }
        function setupResizeAndScrollEventListeners($el, listener) {
          var $scrollParents = findScrollParents($el);
          window.addEventListener("resize", listener, {
            passive: true
          });
          $scrollParents.forEach(function(scrollParent) {
            scrollParent.addEventListener("scroll", listener, {
              passive: true
            });
          });
          return function removeEventListeners() {
            window.removeEventListener("resize", listener, {
              passive: true
            });
            $scrollParents.forEach(function($scrollParent) {
              $scrollParent.removeEventListener("scroll", listener, {
                passive: true
              });
            });
          };
        }
        var Tipvue_type_script_lang_js = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
          name: "vue-treeselect--tip",
          functional: true,
          props: {
            type: {
              type: String,
              required: true
            },
            icon: {
              type: String,
              required: true
            }
          },
          render: function render(context) {
            var h = arguments[0];
            var type = this.type, icon = this.icon;
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": "vue-treeselect__tip vue-treeselect__".concat(type, "-tip")
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": "vue-treeselect__icon-container"
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
              "class": "vue-treeselect__icon-".concat(icon)
            }, null)]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
              "class": "vue-treeselect__tip-text vue-treeselect__".concat(type, "-tip-text")
            }, [this.$slots.default()])]);
          }
        });
        var Tip = Tipvue_type_script_lang_js;
        function Optionvue_type_script_lang_js_isSlot(s) {
          return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(s);
        }
        var arrowPlaceholder, checkMark, minusMark;
        var Option = {
          name: "vue-treeselect--option",
          inject: ["instance"],
          props: {
            node: {
              type: Object,
              required: true
            }
          },
          computed: {
            shouldExpand: function shouldExpand() {
              var instance = this.instance, node = this.node;
              return node.isBranch && instance.shouldExpand(node);
            },
            shouldShow: function shouldShow() {
              var instance = this.instance, node = this.node;
              return instance.shouldShowOptionInMenu(node);
            }
          },
          methods: {
            renderOption: function renderOption() {
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              var optionClass = {
                "vue-treeselect__option": true,
                "vue-treeselect__option--disabled": node.isDisabled,
                "vue-treeselect__option--selected": instance.isSelected(node),
                "vue-treeselect__option--highlight": node.isHighlighted,
                "vue-treeselect__option--matched": instance.localSearch.active && node.isMatched,
                "vue-treeselect__option--hide": !this.shouldShow
              };
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": optionClass,
                "onMouseenter": this.handleMouseEnterOption,
                "data-id": node.id
              }, [this.renderArrow(), this.renderLabelContainer([this.renderCheckboxContainer([this.renderCheckbox()]), this.renderLabel()])]);
            },
            renderSubOptionsList: function renderSubOptionsList() {
              var h = this.$createElement;
              if (!this.shouldExpand)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__list"
              }, [this.renderSubOptions(), this.renderNoChildrenTip(), this.renderLoadingChildrenTip(), this.renderLoadingChildrenErrorTip()]);
            },
            renderArrow: function renderArrow() {
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              if (instance.shouldFlattenOptions && this.shouldShow)
                return null;
              if (node.isBranch) {
                var _slot;
                var arrowClass = {
                  "vue-treeselect__option-arrow": true,
                  "vue-treeselect__option-arrow--rotated": this.shouldExpand
                };
                return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                  "class": "vue-treeselect__option-arrow-container",
                  "onMousedown": this.handleMouseDownOnArrow
                }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("transition"), {
                  "name": "vue-treeselect__option-arrow--prepare",
                  "appear": true
                }, Optionvue_type_script_lang_js_isSlot(_slot = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Arrow, {
                  "class": arrowClass
                }, null)) ? _slot : {
                  default: function _default() {
                    return [_slot];
                  }
                })]);
              }
              if (instance.hasBranchNodes) {
                if (!arrowPlaceholder)
                  arrowPlaceholder = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                    "class": "vue-treeselect__option-arrow-placeholder"
                  }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])("\xA0")]);
                return arrowPlaceholder;
              }
              return null;
            },
            renderLabelContainer: function renderLabelContainer(children) {
              var h = this.$createElement;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__label-container",
                "onMousedown": this.handleMouseDownOnLabelContainer
              }, Optionvue_type_script_lang_js_isSlot(children) ? children : {
                default: function _default() {
                  return [children];
                }
              });
            },
            renderCheckboxContainer: function renderCheckboxContainer(children) {
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              if (instance.single)
                return null;
              if (instance.disableBranchNodes && node.isBranch)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__checkbox-container"
              }, Optionvue_type_script_lang_js_isSlot(children) ? children : {
                default: function _default() {
                  return [children];
                }
              });
            },
            renderCheckbox: function renderCheckbox() {
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              var checkedState = instance.forest.checkedStateMap[node.id];
              var checkboxClass = {
                "vue-treeselect__checkbox": true,
                "vue-treeselect__checkbox--checked": checkedState === CHECKED,
                "vue-treeselect__checkbox--indeterminate": checkedState === INDETERMINATE,
                "vue-treeselect__checkbox--unchecked": checkedState === UNCHECKED,
                "vue-treeselect__checkbox--disabled": node.isDisabled
              };
              if (!checkMark)
                checkMark = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
                  "class": "vue-treeselect__check-mark"
                }, null);
              if (!minusMark)
                minusMark = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
                  "class": "vue-treeselect__minus-mark"
                }, null);
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
                "class": checkboxClass
              }, [checkMark, minusMark]);
            },
            renderLabel: function renderLabel() {
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              var shouldShowCount = node.isBranch && (instance.localSearch.active ? instance.showCountOnSearchComputed : instance.showCount);
              var count = shouldShowCount ? instance.localSearch.active ? instance.localSearch.countMap[node.id][instance.showCountOf] : node.count[instance.showCountOf] : NaN;
              var labelClassName = "vue-treeselect__label";
              var countClassName = "vue-treeselect__count";
              var customLabelRenderer = instance.$slots["option-label"];
              if (customLabelRenderer)
                return customLabelRenderer({
                  node,
                  shouldShowCount,
                  count,
                  labelClassName,
                  countClassName
                });
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("label", {
                "class": labelClassName
              }, [node.label, shouldShowCount && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
                "class": countClassName
              }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])("("), count, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])(")")])]);
            },
            renderSubOptions: function renderSubOptions() {
              var h = this.$createElement;
              var node = this.node;
              if (!node.childrenStates.isLoaded)
                return null;
              return node.children.map(function(childNode) {
                return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("vue-treeselect--option"), {
                  "node": childNode,
                  "key": childNode.id
                }, null);
              });
            },
            renderNoChildrenTip: function renderNoChildrenTip() {
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              if (!node.childrenStates.isLoaded || node.children.length)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "no-children",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.noChildrenText];
                }
              });
            },
            renderLoadingChildrenTip: function renderLoadingChildrenTip() {
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              if (!node.childrenStates.isLoading)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "loading",
                "icon": "loader"
              }, {
                default: function _default() {
                  return [instance.loadingText];
                }
              });
            },
            renderLoadingChildrenErrorTip: function renderLoadingChildrenErrorTip() {
              var _this = this;
              var h = this.$createElement;
              var instance = this.instance, node = this.node;
              if (!node.childrenStates.loadingError)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "error",
                "icon": "error"
              }, {
                default: function _default() {
                  return [node.childrenStates.loadingError, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("a", {
                    "class": "vue-treeselect__retry",
                    "title": instance.retryTitle,
                    "onMousedown": _this.handleMouseDownOnRetry
                  }, [instance.retryText])];
                }
              });
            },
            handleMouseEnterOption: function handleMouseEnterOption(evt) {
              var instance = this.instance, node = this.node;
              if (evt.target !== evt.currentTarget)
                return;
              instance.setCurrentHighlightedOption(node, false);
            },
            handleMouseDownOnArrow: onLeftClick(function handleMouseDownOnOptionArrow() {
              var instance = this.instance, node = this.node;
              instance.toggleExpanded(node);
            }),
            handleMouseDownOnLabelContainer: onLeftClick(function handleMouseDownOnLabelContainer() {
              var instance = this.instance, node = this.node;
              if (node.isBranch && instance.disableBranchNodes) {
                instance.toggleExpanded(node);
              } else {
                instance.select(node);
              }
            }),
            handleMouseDownOnRetry: onLeftClick(function handleMouseDownOnRetry() {
              var instance = this.instance, node = this.node;
              instance.loadChildrenOptions(node);
            })
          },
          render: function render() {
            var _slot2;
            var h = arguments[0];
            var node = this.node;
            var indentLevel = this.instance.shouldFlattenOptions ? 0 : node.level;
            var listItemClass = _defineProperty({
              "vue-treeselect__list-item": true
            }, "vue-treeselect__indent-level-".concat(indentLevel), true);
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": listItemClass
            }, [this.renderOption(), node.isBranch ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("transition"), {
              "name": "vue-treeselect__list--transition"
            }, Optionvue_type_script_lang_js_isSlot(_slot2 = this.renderSubOptionsList()) ? _slot2 : {
              default: function _default() {
                return [_slot2];
              }
            }) : ""]);
          }
        };
        var Optionvue_type_script_lang_js = Option;
        var components_Option = Optionvue_type_script_lang_js;
        function Menuvue_type_script_lang_js_isSlot(s) {
          return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(s);
        }
        var directionMap = {
          top: "top",
          bottom: "bottom",
          above: "top",
          below: "bottom"
        };
        var Menuvue_type_script_lang_js = {
          name: "vue-treeselect--menu",
          inject: ["instance"],
          computed: {
            menuStyle: function menuStyle() {
              var instance = this.instance;
              return {
                maxHeight: instance.maxHeight + "px"
              };
            },
            menuContainerStyle: function menuContainerStyle() {
              var instance = this.instance;
              return {
                zIndex: instance.appendToBody ? null : instance.zIndex
              };
            }
          },
          watch: {
            "instance.menu.isOpen": function instanceMenuIsOpen(newValue) {
              if (newValue) {
                this.$nextTick(this.onMenuOpen);
              } else {
                this.onMenuClose();
              }
            }
          },
          created: function created() {
            this.menuSizeWatcher = null;
            this.menuResizeAndScrollEventListeners = null;
          },
          mounted: function mounted() {
            var instance = this.instance;
            if (instance.menu.isOpen)
              this.$nextTick(this.onMenuOpen);
          },
          unmounted: function unmounted() {
            this.onMenuClose();
          },
          methods: {
            renderMenu: function renderMenu() {
              var h = this.$createElement;
              var instance = this.instance;
              if (!instance.menu.isOpen)
                return null;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "ref": "menu",
                "class": "vue-treeselect__menu",
                "onMousedown": instance.handleMouseDown,
                "style": this.menuStyle
              }, [this.renderBeforeList(), instance.async ? this.renderAsyncSearchMenuInner() : instance.localSearch.active ? this.renderLocalSearchMenuInner() : this.renderNormalMenuInner(), this.renderAfterList()]);
            },
            renderBeforeList: function renderBeforeList() {
              var instance = this.instance;
              var beforeListRenderer = instance.$slots["before-list"];
              return beforeListRenderer ? beforeListRenderer() : null;
            },
            renderAfterList: function renderAfterList() {
              var instance = this.instance;
              var afterListRenderer = instance.$slots["after-list"];
              return afterListRenderer ? afterListRenderer() : null;
            },
            renderNormalMenuInner: function renderNormalMenuInner() {
              var instance = this.instance;
              if (instance.rootOptionsStates.isLoading) {
                return this.renderLoadingOptionsTip();
              } else if (instance.rootOptionsStates.loadingError) {
                return this.renderLoadingRootOptionsErrorTip();
              } else if (instance.rootOptionsStates.isLoaded && instance.forest.normalizedOptions.length === 0) {
                return this.renderNoAvailableOptionsTip();
              } else {
                return this.renderOptionList();
              }
            },
            renderLocalSearchMenuInner: function renderLocalSearchMenuInner() {
              var instance = this.instance;
              if (instance.rootOptionsStates.isLoading) {
                return this.renderLoadingOptionsTip();
              } else if (instance.rootOptionsStates.loadingError) {
                return this.renderLoadingRootOptionsErrorTip();
              } else if (instance.rootOptionsStates.isLoaded && instance.forest.normalizedOptions.length === 0) {
                return this.renderNoAvailableOptionsTip();
              } else if (instance.localSearch.noResults) {
                return this.renderNoResultsTip();
              } else {
                return this.renderOptionList();
              }
            },
            renderAsyncSearchMenuInner: function renderAsyncSearchMenuInner() {
              var instance = this.instance;
              var entry = instance.getRemoteSearchEntry();
              var shouldShowSearchPromptTip = instance.trigger.searchQuery === "" && !instance.defaultOptions;
              var shouldShowNoResultsTip = shouldShowSearchPromptTip ? false : entry.isLoaded && entry.options.length === 0;
              if (shouldShowSearchPromptTip) {
                return this.renderSearchPromptTip();
              } else if (entry.isLoading) {
                return this.renderLoadingOptionsTip();
              } else if (entry.loadingError) {
                return this.renderAsyncSearchLoadingErrorTip();
              } else if (shouldShowNoResultsTip) {
                return this.renderNoResultsTip();
              } else {
                return this.renderOptionList();
              }
            },
            renderOptionList: function renderOptionList() {
              var h = this.$createElement;
              var instance = this.instance;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__list"
              }, [instance.forest.normalizedOptions.map(function(rootNode) {
                return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(components_Option, {
                  "node": rootNode,
                  "key": rootNode.id
                }, null);
              })]);
            },
            renderSearchPromptTip: function renderSearchPromptTip() {
              var h = this.$createElement;
              var instance = this.instance;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "search-prompt",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.searchPromptText];
                }
              });
            },
            renderLoadingOptionsTip: function renderLoadingOptionsTip() {
              var h = this.$createElement;
              var instance = this.instance;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "loading",
                "icon": "loader"
              }, {
                default: function _default() {
                  return [instance.loadingText];
                }
              });
            },
            renderLoadingRootOptionsErrorTip: function renderLoadingRootOptionsErrorTip() {
              var h = this.$createElement;
              var instance = this.instance;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "error",
                "icon": "error"
              }, {
                default: function _default() {
                  return [instance.rootOptionsStates.loadingError, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("a", {
                    "class": "vue-treeselect__retry",
                    "onClick": instance.loadRootOptions,
                    "title": instance.retryTitle
                  }, [instance.retryText])];
                }
              });
            },
            renderAsyncSearchLoadingErrorTip: function renderAsyncSearchLoadingErrorTip() {
              var h = this.$createElement;
              var instance = this.instance;
              var entry = instance.getRemoteSearchEntry();
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "error",
                "icon": "error"
              }, {
                default: function _default() {
                  return [entry.loadingError, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("a", {
                    "class": "vue-treeselect__retry",
                    "onClick": instance.handleRemoteSearch,
                    "title": instance.retryTitle
                  }, [instance.retryText])];
                }
              });
            },
            renderNoAvailableOptionsTip: function renderNoAvailableOptionsTip() {
              var h = this.$createElement;
              var instance = this.instance;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "no-options",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.noOptionsText];
                }
              });
            },
            renderNoResultsTip: function renderNoResultsTip() {
              var h = this.$createElement;
              var instance = this.instance;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tip, {
                "type": "no-results",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.noResultsText];
                }
              });
            },
            onMenuOpen: function onMenuOpen() {
              this.adjustMenuOpenDirection();
              this.setupMenuSizeWatcher();
              this.setupMenuResizeAndScrollEventListeners();
            },
            onMenuClose: function onMenuClose() {
              this.removeMenuSizeWatcher();
              this.removeMenuResizeAndScrollEventListeners();
            },
            adjustMenuOpenDirection: function adjustMenuOpenDirection() {
              var instance = this.instance;
              if (!instance.menu.isOpen)
                return;
              var $menu = instance.getMenu();
              var $control = instance.getControl();
              var menuRect = $menu.getBoundingClientRect();
              var controlRect = $control.getBoundingClientRect();
              var menuHeight = menuRect.height;
              var viewportHeight = window.innerHeight;
              var spaceAbove = controlRect.top;
              var spaceBelow = window.innerHeight - controlRect.bottom;
              var isControlInViewport = controlRect.top >= 0 && controlRect.top <= viewportHeight || controlRect.top < 0 && controlRect.bottom > 0;
              var hasEnoughSpaceBelow = spaceBelow > menuHeight + MENU_BUFFER;
              var hasEnoughSpaceAbove = spaceAbove > menuHeight + MENU_BUFFER;
              if (!isControlInViewport) {
                instance.closeMenu();
              } else if (instance.openDirection !== "auto") {
                instance.menu.placement = directionMap[instance.openDirection];
              } else if (hasEnoughSpaceBelow || !hasEnoughSpaceAbove) {
                instance.menu.placement = "bottom";
              } else {
                instance.menu.placement = "top";
              }
            },
            setupMenuSizeWatcher: function setupMenuSizeWatcher() {
              var instance = this.instance;
              var $menu = instance.getMenu();
              if (this.menuSizeWatcher)
                return;
              this.menuSizeWatcher = {
                remove: watchSize($menu, this.adjustMenuOpenDirection)
              };
            },
            setupMenuResizeAndScrollEventListeners: function setupMenuResizeAndScrollEventListeners() {
              var instance = this.instance;
              var $control = instance.getControl();
              if (this.menuResizeAndScrollEventListeners)
                return;
              this.menuResizeAndScrollEventListeners = {
                remove: setupResizeAndScrollEventListeners($control, this.adjustMenuOpenDirection)
              };
            },
            removeMenuSizeWatcher: function removeMenuSizeWatcher() {
              if (!this.menuSizeWatcher)
                return;
              this.menuSizeWatcher.remove();
              this.menuSizeWatcher = null;
            },
            removeMenuResizeAndScrollEventListeners: function removeMenuResizeAndScrollEventListeners() {
              if (!this.menuResizeAndScrollEventListeners)
                return;
              this.menuResizeAndScrollEventListeners.remove();
              this.menuResizeAndScrollEventListeners = null;
            }
          },
          render: function render() {
            var _slot;
            var h = arguments[0];
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "ref": "menu-container",
              "class": "vue-treeselect__menu-container",
              "style": this.menuContainerStyle
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("transition"), {
              "name": "vue-treeselect__menu--transition"
            }, Menuvue_type_script_lang_js_isSlot(_slot = this.renderMenu()) ? _slot : {
              default: function _default() {
                return [_slot];
              }
            })]);
          }
        };
        var Menu = Menuvue_type_script_lang_js;
        var PortalTarget = {
          name: "vue-treeselect--portal-target",
          inject: ["instance"],
          watch: {
            "instance.menu.isOpen": function instanceMenuIsOpen(newValue) {
              if (newValue) {
                this.setupHandlers();
              } else {
                this.removeHandlers();
              }
            },
            "instance.menu.placement": function instanceMenuPlacement() {
              this.updateMenuContainerOffset();
            }
          },
          created: function created() {
            this.controlResizeAndScrollEventListeners = null;
            this.controlSizeWatcher = null;
          },
          mounted: function mounted() {
            var instance = this.instance;
            if (instance.menu.isOpen)
              this.setupHandlers();
          },
          methods: {
            setupHandlers: function setupHandlers() {
              this.updateWidth();
              this.updateMenuContainerOffset();
              this.setupControlResizeAndScrollEventListeners();
              this.setupControlSizeWatcher();
            },
            removeHandlers: function removeHandlers() {
              this.removeControlResizeAndScrollEventListeners();
              this.removeControlSizeWatcher();
            },
            setupControlResizeAndScrollEventListeners: function setupControlResizeAndScrollEventListeners() {
              var instance = this.instance;
              var $control = instance.getControl();
              if (this.controlResizeAndScrollEventListeners)
                return;
              this.controlResizeAndScrollEventListeners = {
                remove: setupResizeAndScrollEventListeners($control, this.updateMenuContainerOffset)
              };
            },
            setupControlSizeWatcher: function setupControlSizeWatcher() {
              var _this = this;
              var instance = this.instance;
              var $control = instance.getControl();
              if (this.controlSizeWatcher)
                return;
              this.controlSizeWatcher = {
                remove: watchSize($control, function() {
                  _this.updateWidth();
                  _this.updateMenuContainerOffset();
                })
              };
            },
            removeControlResizeAndScrollEventListeners: function removeControlResizeAndScrollEventListeners() {
              if (!this.controlResizeAndScrollEventListeners)
                return;
              this.controlResizeAndScrollEventListeners.remove();
              this.controlResizeAndScrollEventListeners = null;
            },
            removeControlSizeWatcher: function removeControlSizeWatcher() {
              if (!this.controlSizeWatcher)
                return;
              this.controlSizeWatcher.remove();
              this.controlSizeWatcher = null;
            },
            updateWidth: function updateWidth() {
              var instance = this.instance;
              var $portalTarget = this.$el;
              var $control = instance.getControl();
              var controlRect = $control.getBoundingClientRect();
              $portalTarget.style.width = controlRect.width + "px";
            },
            updateMenuContainerOffset: function updateMenuContainerOffset() {
              var instance = this.instance;
              var $control = instance.getControl();
              var $portalTarget = this.$el;
              var controlRect = $control.getBoundingClientRect();
              var portalTargetRect = $portalTarget.getBoundingClientRect();
              var offsetY = instance.menu.placement === "bottom" ? controlRect.height : 0;
              var left = Math.round(controlRect.left - portalTargetRect.left) + "px";
              var top = Math.round(controlRect.top - portalTargetRect.top + offsetY) + "px";
              var menuContainerStyle = this.$refs.menu.$refs["menu-container"].style;
              var transformVariations = ["transform", "webkitTransform", "MozTransform", "msTransform"];
              var transform2 = find(transformVariations, function(t) {
                return t in document.body.style;
              });
              menuContainerStyle[transform2] = "translate(".concat(left, ", ").concat(top, ")");
            }
          },
          render: function render() {
            var h = arguments[0];
            var instance = this.instance;
            var portalTargetClass = ["vue-treeselect__portal-target", instance.wrapperClass];
            var portalTargetStyle = {
              zIndex: instance.zIndex
            };
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
              "class": portalTargetClass,
              "style": portalTargetStyle,
              "data-instance-id": instance.getInstanceId()
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Menu, {
              "ref": "menu"
            }, null)]);
          },
          unmounted: function unmounted() {
            this.removeHandlers();
          }
        };
        var placeholder;
        var MenuPortalvue_type_script_lang_js = {
          name: "vue-treeselect--menu-portal",
          created: function created() {
            this.portalTarget = null;
          },
          mounted: function mounted() {
            this.setup();
          },
          unmounted: function unmounted() {
            this.teardown();
          },
          methods: {
            setup: function setup() {
              var el = document.createElement("div");
              document.body.appendChild(el);
              this.portalTarget = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createApp"])(_objectSpread2({
                parent: this
              }, PortalTarget));
              this.portalTarget.mount(el);
            },
            teardown: function teardown() {
              document.body.removeChild(this.portalTarget.$el);
              this.portalTarget.$el.innerHTML = "";
              this.portalTarget.$destroy();
              this.portalTarget = null;
            }
          },
          render: function render() {
            var h = arguments[0];
            if (!placeholder)
              placeholder = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                "class": "vue-treeselect__menu-placeholder"
              }, null);
            return placeholder;
          }
        };
        var MenuPortal = MenuPortalvue_type_script_lang_js;
        var Treeselectvue_type_script_lang_js = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
          name: "vue-treeselect",
          mixins: [treeselectMixin],
          components: {
            HiddenFields,
            Control,
            Menu,
            MenuPortal
          },
          computed: {
            wrapperClass: function wrapperClass() {
              return {
                "vue-treeselect": true,
                "vue-treeselect--single": this.single,
                "vue-treeselect--multi": this.multiple,
                "vue-treeselect--searchable": this.searchable,
                "vue-treeselect--disabled": this.disabled,
                "vue-treeselect--focused": this.trigger.isFocused,
                "vue-treeselect--has-value": this.hasValue,
                "vue-treeselect--open": this.menu.isOpen,
                "vue-treeselect--open-above": this.menu.placement === "top",
                "vue-treeselect--open-below": this.menu.placement === "bottom",
                "vue-treeselect--branch-nodes-disabled": this.disableBranchNodes,
                "vue-treeselect--append-to-body": this.appendToBody
              };
            }
          }
        });
        Treeselectvue_type_script_lang_js.render = Treeselectvue_type_template_id_5905dd6c_render;
        var Treeselect = Treeselectvue_type_script_lang_js;
        var style = __webpack_require__("d15f");
        var src_0 = Treeselect;
        var entry_lib = __webpack_exports__["default"] = src_0;
      },
      "fb6a": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var isObject2 = __webpack_require__("861d");
        var isArray2 = __webpack_require__("e8b5");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var toLength = __webpack_require__("50c4");
        var toIndexedObject = __webpack_require__("fc6a");
        var createProperty = __webpack_require__("8418");
        var wellKnownSymbol = __webpack_require__("b622");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
        var USES_TO_LENGTH = arrayMethodUsesToLength("slice", { ACCESSORS: true, 0: 0, 1: 2 });
        var SPECIES = wellKnownSymbol("species");
        var nativeSlice = [].slice;
        var max = Math.max;
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          slice: function slice(start, end) {
            var O = toIndexedObject(this);
            var length = toLength(O.length);
            var k = toAbsoluteIndex(start, length);
            var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
            var Constructor, result, n;
            if (isArray2(O)) {
              Constructor = O.constructor;
              if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
                Constructor = void 0;
              } else if (isObject2(Constructor)) {
                Constructor = Constructor[SPECIES];
                if (Constructor === null)
                  Constructor = void 0;
              }
              if (Constructor === Array || Constructor === void 0) {
                return nativeSlice.call(O, k, fin);
              }
            }
            result = new (Constructor === void 0 ? Array : Constructor)(max(fin - k, 0));
            for (n = 0; k < fin; k++, n++)
              if (k in O)
                createProperty(result, n, O[k]);
            result.length = n;
            return result;
          }
        });
      },
      "fc6a": function(module2, exports2, __webpack_require__) {
        var IndexedObject = __webpack_require__("44ad");
        var requireObjectCoercible = __webpack_require__("1d80");
        module2.exports = function(it) {
          return IndexedObject(requireObjectCoercible(it));
        };
      },
      "fdbc": function(module2, exports2) {
        module2.exports = {
          CSSRuleList: 0,
          CSSStyleDeclaration: 0,
          CSSValueList: 0,
          ClientRectList: 0,
          DOMRectList: 0,
          DOMStringList: 0,
          DOMTokenList: 1,
          DataTransferItemList: 0,
          FileList: 0,
          HTMLAllCollection: 0,
          HTMLCollection: 0,
          HTMLFormElement: 0,
          HTMLSelectElement: 0,
          MediaList: 0,
          MimeTypeArray: 0,
          NamedNodeMap: 0,
          NodeList: 1,
          PaintRequestList: 0,
          Plugin: 0,
          PluginArray: 0,
          SVGLengthList: 0,
          SVGNumberList: 0,
          SVGPathSegList: 0,
          SVGPointList: 0,
          SVGStringList: 0,
          SVGTransformList: 0,
          SourceBufferList: 0,
          StyleSheetList: 0,
          TextTrackCueList: 0,
          TextTrackList: 0,
          TouchList: 0
        };
      },
      "fdbf": function(module2, exports2, __webpack_require__) {
        var NATIVE_SYMBOL = __webpack_require__("4930");
        module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
      },
      "ffd6": function(module2, exports2, __webpack_require__) {
        var baseGetTag = __webpack_require__("3729"), isObjectLike = __webpack_require__("1310");
        var symbolTag = "[object Symbol]";
        function isSymbol2(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        module2.exports = isSymbol2;
      }
    });
  }
});

// dep:vue3-treeselect
init_define_process_env();
var vue3_treeselect_default = require_vue3_treeselect_common();
export {
  vue3_treeselect_default as default
};
//# sourceMappingURL=vue3-treeselect.js.map
